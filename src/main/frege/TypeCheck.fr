module punkt0.TypeCheck where
import punkt0.Analyzer
import Data.HashMap
import punkt0.Positioned
import punkt0.Reporter
import Data.Traversable(traverse)
import Data.List(sort)
import punkt0.parser.Grammar
import punkt0.ScalaShow
import lexer.Lexer(scanTokens, FileIterator)
import parser.Parser(parse)
import punkt0.lexer.Tokens as Tokens()

data TType
    = TBool
    | TInt
    | TString
    | TUnit
    | TClass {name :: String}
derive Show TType
derive Eq TType

type Context = HashMap String TType
type TypeCheck a = Accumulate [(String, Position)] a

tType :: Type -> TType
tType Bool = TBool
tType Int = TInt
tType String = TString
tType Unit = TUnit
tType (User id) = TClass (id.str)

typeIdentifier :: Context -> Identifier -> TypeCheck TType
typeIdentifier context identifier
    = maybe
        (report1 ("Not declared: "++ identifier.str, identifier.pos))
        pure
        (lookup (identifier.str) context)

unify :: TType -> TType -> Position -> TypeCheck TType
unify t t2 pos =
    if t == t2 -- TODO: Change to least upper bound of t and t2
        then pure t
        else report1 $ ("Cannot unify type " ++ show t ++ " with " ++ show t2, pos)

assertType :: TType -> TypeCheck TType -> Position -> TypeCheck TType
assertType t result pos = case result of
    ARight t2 -> unify t t2 pos
    errors -> errors

assertEqual :: TypeCheck TType -> TypeCheck TType -> Position -> TypeCheck TType
assertEqual res1 res2 pos = case (res1, res2) of
    (ARight t, ARight t2) -> unify t t2 pos
    _ -> res1 *> res2 -- this will merge the errors from the results

typeBinaryOp :: Context -> BinOp -> Expression -> Expression -> Position -> TypeCheck TType
typeBinaryOp context Plus lhs rhs pos
    = case (typeExpression context lhs, typeExpression context rhs) of
        (ARight TInt, ARight TInt) -> pure TInt
        (ARight TInt, ARight TString) -> pure TString
        (ARight TString, ARight TInt) -> pure TString
        (ARight TString, ARight TString) -> pure TString
        (ARight t, ARight t2) -> report1 $ ("Expected add operand types, got: " ++ show t ++ " + " ++ show t2, pos)
        (res1, res2) -> res1 *> res2
typeBinaryOp context And lhs rhs pos
    = assertType TBool (typeExpression context lhs) pos
    *> assertType TBool (typeExpression context rhs) pos
typeBinaryOp context Or lhs rhs pos
    = assertType TBool (typeExpression context lhs) pos
    *> assertType TBool (typeExpression context rhs) pos
typeBinaryOp context Equals lhs rhs pos
    = case (typeExpression context lhs, typeExpression context rhs) of
        (ARight (TClass _), ARight (TClass _)) -> pure TBool
        (ARight (TClass _), ARight _) -> report1 ("fail to ", pos)
        (ARight _, ARight (TClass _)) -> report1 ("fail to ", pos)
        (ARight t, ARight t2)  -> unify t t2 pos
        (res1, res2) -> res1 *> res2
typeBinaryOp context LessThan lhs rhs pos
    = typeBinaryOp context Equals lhs rhs pos -- same rules as for equality
typeBinaryOp context Minus lhs rhs pos
    = case (typeExpression context lhs, typeExpression context rhs) of
        (ARight TInt, ARight TInt) -> pure TInt
        (ARight t, ARight t2) -> report1 ("Expected numeric types, got: " ++ show t ++ " and " ++ show t2, pos)
        (res1, res2) -> res1 *> res2
typeBinaryOp context Times lhs rhs pos
    = typeBinaryOp context Minus lhs rhs pos
typeBinaryOp context Div lhs rhs pos
    = typeBinaryOp context Minus lhs rhs pos

typeExpression :: Context -> Expression -> TypeCheck TType
typeExpression _ (LitInt{}) = pure TInt
typeExpression _ (LitString{}) = pure TString
typeExpression _ (LitTrue{}) = pure TBool
typeExpression _ (LitFalse{}) = pure TBool
typeExpression _ (LitNull{}) = pure TUnit
typeExpression _ (New{obj}) = pure (TClass obj.str)
typeExpression context (Identifier{id})
    = typeIdentifier context id
typeExpression context (LitThis pos)
    = maybe (report1 $ ("this outside of class declaration", pos)) pure (lookup "this" context)
typeExpression context (BinOp{lhs, op, rhs, pos}) = typeBinaryOp context op lhs rhs pos
typeExpression context (Not {expr, pos})
    = assertType TBool (typeExpression context expr) pos
typeExpression context (Block es _)
    = fmap last $ traverse (typeExpression context) es
typeExpression context (If predicate body Nothing pos)
    = assertType TBool (typeExpression context predicate) pos
    *> typeExpression context body
typeExpression context (If predicate body (Just elseBody) pos)
    = assertType TBool (typeExpression context predicate) pos
    *> assertEqual (typeExpression context body) (typeExpression context elseBody) pos
typeExpression context (While {predicate, body, pos})
    = assertType TBool (typeExpression context predicate) pos
    *> typeExpression context body
typeExpression context (Println {expr})
    = typeExpression context expr
    *> pure TUnit
typeExpression context (Assign {var, expr, pos})
    = typeIdentifier context var
    *> typeExpression context expr

typecheck
    = missing baseClass extends
    *> cycleChecks is
    *> (mapError show $ typeIdentifier (empty) (ID "asd" initialPosition))
    where
        baseClass = "Any"
        extends = fromList [("a", "b"), ("b", "c"), ("c", "a"), ("d", "a"), ("e", "Any"), ("f", "e"), ("h", "missing")]
        is = inheritance baseClass extends

parseCode code parser =
    let
        tokens = (scanTokens Tokens.token) . FileIterator.from $ code
        parsed = parse parser tokens
    in case parsed of
        Right ([], parseTree) -> Just parseTree
        Right (_, parseTree) -> Just parseTree
        _ -> Nothing

pos = initialPosition

main = do
    println typecheck
    println $ typeIdentifier empty (ID "asd" pos)
    println $ typeIdentifier (fromList [("asd", TInt)]) (ID "asd" pos)
    println $ typeExpression empty (Block [LitInt 2 pos, LitString "asd" pos] pos)
    println . fmap (typeExpression empty) $ parseCode "if (true) {3;5} else 4" (expression <* tokenEOF)
    println . fmap (typeExpression empty) $ parseCode "if (false) {3;false} else true" (expression <* tokenEOF)
    println . fmap (typeExpression empty) $ parseCode "2 + 3" (expression <* tokenEOF)
    println . fmap (typeExpression empty) $ parseCode "2 + \"3\"" (expression <* tokenEOF)
    println . fmap (typeExpression empty) $ parseCode "    true + \"3\"" (expression <* tokenEOF)
