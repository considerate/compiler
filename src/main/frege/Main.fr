module Main where
import lexer.Lexer (scanTokens, FileIterator, Lexeme(Bad))
import lexer.Punkt0Lexer (identifier, token, Token())
import parser.Punkt0Parser (program, expression, simpleexpression, Program)
import frege.control.monad.trans.MonadIO
import Context
import Phase
import punkt0.Reporter
import Data.Traversable(traverse)
import parser.Punkt0Pretty (pretty, intendent)

tokens :: String -> [Lexeme Token]
tokens = (scanTokens token) . FileIterator.from

isBad (Bad _) = true
isBad _ = false

tokenPhase :: Maybe String -> Phase [Lexeme Token]
tokenPhase file =
    phase $ fmap tokenize (input file)
    where
        tokenize :: String -> Accumulate [String] [Lexeme Token]
        tokenize str =
            let
                tokens = (scanTokens token) . FileIterator.from $ str
                bads = filter isBad tokens
            in traverse (report1 . show) bads *> pure tokens
        input :: Maybe String -> IO String
        input file = case file of
            Nothing -> getContents
            (Just name) -> readFile name

parsePhase :: [Lexeme Token] -> Phase Program
parsePhase tokens =
    let result = program.run $ tokens
    in phase $ pure $ case result of
        [] = report1 "No possible parse"
        [([],p)] = pure p
        [(t:_, _)] = report1 $ "unexpected" ++ show t
        _ = report1 "Ambiguous parse"

displayHelp :: IO ()
displayHelp = print "Well. Don't ask me."

prettyPrint :: Program -> IO ()
prettyPrint x = println $ unwords . map show . intendent $ pretty x

crashAndBurn :: Show e => [e] -> IO ()
crashAndBurn errors = mapM_ println errors >> System.exit 1

runIO :: Show e => (a -> IO ()) -> ([e] | a) -> IO ()
runIO ok result = either crashAndBurn ok result

main :: [String] -> IO ()
main args
    | otherwise =
        let
            context = parseFlags args defaultContext
            tokens = tokenPhase context.file
            parseTree = tokens >>= parsePhase
            phases = do
                when context.tokens ((runPhase tokens) >>= (runIO $ mapM_ println))
                when context.ast ((runPhase parseTree) >>= (runIO $ println . show))
                ((runPhase parseTree) >>= (runIO $ prettyPrint))
        in phases
