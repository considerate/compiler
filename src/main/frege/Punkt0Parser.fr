module parser.Punkt0Parser where
import parser.Parser
import lexer.Punkt0Lexer as Tokens(Token, getIdentifierString, getLiteral, isLiteral)

tokenOp :: Tokens.Operator -> Parser Token Token
tokenOp t = symbol (Tokens.Op t)

tokenLit :: Tokens.Literal -> Parser Token Token
tokenLit t = symbol (Tokens.Literal t)

tokenKey :: Tokens.Keyword -> Parser Token Token
tokenKey t = symbol (Tokens.Keyword t)

tokenType :: Tokens.Type -> Parser Token Token
tokenType t = symbol (Tokens.Type t)

data Program = Program [ClassDeclaration] MainDeclaration

program :: Parser Token Program
program = fmap Program (many classDeclaration) <*> mainDeclaration

data ClassDeclaration = Class
    { name :: Identifier
    , extends :: (Maybe Identifier)
    , vars :: [VarDeclaration]
    , methods :: [MethodDeclaration]
    }
derive Show Program
derive Show ClassDeclaration
derive Show MainDeclaration
derive Show VarDeclaration
derive Show MethodDeclaration
derive Show Type

wrapping start mid after = start *> mid <* after
braces mid = wrapping (symbol Tokens.LBrace) mid (symbol Tokens.RBrace)
parens mid = wrapping (symbol Tokens.LParen) mid (symbol Token.RParen)

classDeclaration :: Parser Token ClassDeclaration
classDeclaration = do
    tokenKey Tokens.Class
    name <- identifier
    extends <- optional (tokenKey Tokens.Extends >> identifier)
    (vars, methods) <- braces $ fmap (,) (many varDeclaration) <*> (many methodDeclaration)
    return $ Class name extends vars methods

data MainDeclaration = Main
    { name :: Identifier
    , methodName :: Identifier
    , body :: [Expression]
    }

mainDeclaration :: Parser Token MainDeclaration
mainDeclaration = do
    tokenKey Tokens.Object
    name <- identifier
    braces $ do
        tokenKey Tokens.Def
        methodName <- identifier
        symbol Tokens.LParen
        symbol Tokens.RParen
        symbol Tokens.Colon
        tokenType Tokens.UnitType
        tokenOp Tokens.Assign
        body <- braces $
            list expression (symbol Tokens.SemiColon)
        return $ Main name methodName body


data VarDeclaration = Var {name :: Identifier, varType :: Type, expr :: Expression}

varDeclaration :: Parser Token VarDeclaration
varDeclaration = do
    tokenKey Tokens.Var
    name <- identifier
    symbol Tokens.Colon
    t <- typeParser
    tokenOp Tokens.Assign
    expr <- expression
    return $ Var name t expr

data MethodDeclaration = MethodDeclaration
    { override :: Bool
    , name :: Identifier
    , args :: [(Identifier, Type)]
    , returnType :: Type
    , vars :: [VarDeclaration]
    , exprs :: [Expression]
    }

list :: Parser Token a -> Parser Token b -> Parser Token [a]
list elem separator = (fmap (:) elem <*> many (separator *> elem)) <|> pure []

methodDeclaration :: Parser Token MethodDeclaration
methodDeclaration = do
        override <- (fmap isJust . optional . tokenKey) Tokens.Override
        tokenKey Tokens.Def
        name <- identifier
        symbol Tokens.LParen
        args <- parseArgs
        returnType <- typeParser
        symbol Tokens.LBrace
        vars <- many varDeclaration
        exprs <- list expression (symbol Tokens.SemiColon)
        symbol Tokens.RBrace
        return $ MethodDeclaration override name args returnType vars exprs
    where
        parseArg = do
            arg <- identifier
            symbol Tokens.Colon
            t <- typeParser
            return (arg, t)
        parseArgs = list parseArg (symbol Tokens.Comma)




data Type
    = Bool
    | Int
    | String
    | Unit
    | User {typeName :: Identifier}

typeParser :: Parser Token Type
typeParser =
    (tokenType Tokens.BooleanType *> pure Bool)
    <|> (tokenType Tokens.IntType *> pure Int)
    <|> (tokenType Tokens.StringType *> pure String)
    <|> (tokenType Tokens.UnitType *> pure Unit)
    <|> (fmap User identifier)

data Identifier
    = ID String
derive Show Identifier

identifier :: Parser Token Identifier
identifier =
    fmap (ID . unJust . getIdentifierString) $
        satisfy (isJust . getIdentifierString)

data BinOp
    = And
    | Or
    | Equals
    | LessThan
    | Plus
    | Minus
    | Times
    | Div
derive Show BinOp

data Expression
    = BinOp {lhs :: Expression, op :: BinOp, rhs :: Expression}
    | MethodCall Expression Identifier [Expression]
    | LitInt Int
    | LitString String
    | LitTrue
    | LitFalse
    | Identifier {id :: Identifier}
    | LitThis
    | LitNull
    | New {obj ::Identifier}
    | Not {expr :: Expression}
    | Parens Expression
    | Block [Expression]
    | If { predicate :: Expression
         , body :: Expression
         , elseBody :: (Maybe Expression)
         }
    | While {predicate :: Expression, body :: Expression}
    | Println {expr :: Expression}
    | Assign {var :: Identifier, expr :: Expression}
derive Show Expression

binOp :: Parser Token Expression -> Parser Token BinOp -> Parser Token Expression
binOp stronger op
    = do
        e <- stronger;
        result <- (optional $ fmap (,) op <*> stronger)
        case result of
            Nothing -> return e
            Just (operator, e2) -> return $ BinOp e operator e2


expression = logical

logical :: Parser Token Expression
logical = binOp comparative op
    where
        op = (tokenOp Tokens.And *> pure And)
            <|> (tokenOp Tokens.Or *> pure Or)

comparative :: Parser Token Expression
comparative = binOp additive op
    where
        op = (tokenOp Tokens.Equals *> pure Equals)
            <|> (tokenOp Tokens.LT *> pure LessThan)

additive :: Parser Token Expression
additive = binOp multiplicative op
    where
        op = (tokenOp Tokens.Plus *> pure Plus)
            <|> (tokenOp Tokens.Minus *> pure Minus)

multiplicative = binOp methodCall op
    where
        op = (tokenOp Tokens.Times *> pure Times)
            <|> (tokenOp Tokens.Div *> pure Div)

literalToExpression :: Tokens.Literal -> Expression
literalToExpression (Tokens.LitInt i) = LitInt i
literalToExpression (Tokens.LitString s) = LitString s
literalToExpression Tokens.LitTrue = LitTrue
literalToExpression Tokens.LitFalse = LitFalse
literalToExpression Tokens.LitNull = LitNull
literalToExpression Tokens.LitThis = LitThis

methodCall :: Parser Token Expression
methodCall = do
    obj <- simpleexpression
    call <- optional $ do
        symbol Tokens.Dot
        method <- identifier
        args <- parens $ list expression (symbol Tokens.Comma)
        return $ MethodCall obj method args
    return $ case call of
        Nothing -> obj
        Just call -> call

simpleexpression =
    (parens expression)
    <|> (fmap Block $ braces $ list expression (symbol Tokens.SemiColon))
    <|> (fmap (literalToExpression . getLiteral) (satisfy isLiteral))
    <|> (fmap New $ tokenKey Tokens.New *> identifier <* parens (pure ()))
    <|> (fmap Not $ symbol Tokens.Bang *> expression)
    <|> (fmap Println $ tokenKey Tokens.Println *> parens expression)
    <|> ifCase
    <|> whileLoop
    <|> (fmap Assign identifier <*> (tokenOp Tokens.Assign *> expression))
    <|> fmap Identifier identifier
    where
        ifCase = do
            tokenKey Tokens.If
            predicate <- parens expression
            body <- expression
            elseBody <- optional expression
            return $ If predicate body elseBody
        whileLoop = do
            tokenKey Tokens.While
            predicate <- parens expression
            body <- expression
            return $ While predicate body


