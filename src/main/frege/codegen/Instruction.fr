module punkt0.codegen.Instruction where
import punkt0.parser.Grammar
import punkt0.Typed

type ClassName = String
type QualifiedClass = String
type FieldName = String
type Method = String
type VarId = Int
type Label = String

data Instruction
    = LineNum Int
    | Label String
    | Goto String
    | Return
    | Push Int
    | PushStr String
    | ILoad VarId
    | ALoad VarId
    | IStore VarId
    | AStore VarId
    | IADD
    | ISUB
    | IMUL
    | IDIV
    | IXOR
    | IUSHR
    | Swap
    | IfNe Label
    | Invoke QualifiedClass String TType
    | InvokeSpecial QualifiedClass String TType
    | DefaultNew QualifiedClass
    | GetStatic QualifiedClass FieldName TType
    | PutField QualifiedClass FieldName TType
    | GetField QualifiedClass FieldName TType
    | Branch
        { pred :: [Instruction]
        , thenBody :: [Instruction]
        , elseBody :: [Instruction]
        }
    | Loop
        { pred :: [Instruction]
        , body :: [Instruction]
        }
    | GetSign -- Use shift to determin sign. Positive number yields 0.
derive Show Instruction

data Field
    = FieldCode
        { t :: TType
        , name :: FieldName
        , code :: [Instruction]
        }
derive Show Field

data MethodCode
    = MethodCode
        { name :: String
        , args :: [TType]
        , vars :: [Int]
        , returnType :: TType
        , body :: [Instruction]
        }
derive Show MethodCode

data Class
    = ClassCode
        { name :: ClassName
        , extends :: Maybe QualifiedClass
        , fields :: [Field]
        , methods :: [MethodCode]
        }
derive Show Class

data Main
    = MainCode
        { name :: ClassName
        , body :: [Instruction]
        , vars :: [Int]
        }
derive Show Main

data Prog
    = ProgramCode ([Class], Main)
derive Show Prog

flattenInstruction label (Branch p t e)
    = (p' ++ [IfNe elseLabel] ++ t' ++ [Goto afterLabel, Label elseLabel] ++ e' ++ [Label afterLabel], label3)
    where
        elseLabel = "else_" ++ (show label)
        afterLabel = "after_" ++ (show (label+1))
        label0 = label+2
        (p', label1) = flattenInstructions p label0
        (t', label2) = flattenInstructions t label1
        (e', label3) = flattenInstructions e label2
flattenInstruction label i = ([i], label)

flattenInstructions :: [Instruction] -> Int -> ([Instruction], Int)
flattenInstructions xs label0 = (concat yss, label'')
    where
        (yss, label'') = foldr flattenOne ([[]], label0) xs
        flattenOne x (yss, label) = let
            (ys', label') = flattenInstruction label x
            in (ys' : yss, label')

flattenInstructions_ :: [Instruction] -> [Instruction]
flattenInstructions_ xs = fst $ flattenInstructions xs 0

compileExpression :: Expression -> [Instruction]
compileExpression (Typed TInt (BinOp e1 op e2 pos)) = case (e1.t,e2.t) of
    (TInt,TInt) -> compileExpression e2 ++ compileExpression e1 ++ case op of
        Plus -> [LineNum pos.line, IADD]
        Minus -> [LineNum pos.line, ISUB]
        Times -> [LineNum pos.line, IMUL]
        Div -> [LineNum pos.line, IDIV]

compileExpression (Typed TBool (BinOp e1 op e2 pos)) = case (e1.t,e2.t) of
    (TInt,TInt) -> compileExpression e2 ++ compileExpression e1 ++ case op of
        Equals -> [LineNum pos.line, IXOR]
        -- LessThan implemented using bit-magic instead of branching-logic.
        LessThan -> [LineNum pos.line, Swap, ISUB, Push 31, Swap, IUSHR]
    (TBool,TBool) -> case op of
        Equals -> compileExpression e2 ++ compileExpression e1 ++ [LineNum pos.line, IXOR]
        And -> compileExpression (Typed TBool 
            (If e1
                (If e2
                    (Typed TBool (LitTrue pos))
                    (Just (Typed TBool (LitFalse pos)))
                    pos)
                (Just (Typed TBool (LitFalse pos)))
                pos))
        Or -> compileExpression (Typed TBool 
            (If e1
                (Typed TBool (LitTrue pos))
                (Just (Typed TBool (If e2
                    (Typed TBool (LitTrue pos))
                    (Just (Typed TBool (LitFalse pos)))
                    pos)))
            pos))

compileExpression (Println (Typed t expr) pos)
    = [LineNum pos.line, GetStatic "java/lang/System" "out" (TClass "java/io/PrintStream")]
        ++ compileExpression (Typed t expr)
        ++ [Invoke "java/io/PrintStream" "println" (TMethod ([t],TUnit))]
compileExpression (MethodCall (Typed (TClass classType) c) (Symbol _ _ mtype method) args pos)
    = LineNum pos.line : compileExpression c ++ concatMap compileExpression args ++ [Invoke classType (nameOf method) mtype]
compileExpression (New (Symbol _ _ (TClass classType) obj) pos)
    = [LineNum pos.line, DefaultNew classType]
compileExpression (LitInt i pos) = [LineNum pos.line, Push i]
compileExpression (LitString s pos) = [LineNum pos.line, PushStr s]
compileExpression (LitFalse pos) = [LineNum pos.line, Push 1]
compileExpression (LitTrue pos) = [LineNum pos.line, Push 0]
compileExpression (Identifier (Symbol symid (FieldSymbol c) t name) pos) = [LineNum pos.line,ALoad 0, GetField c (nameOf name) t]
compileExpression (Identifier (Symbol symid (LocalSymbol _ i) t name) pos) = [LineNum pos.line, load t i]
    where
        load TInt = ILoad
        load TBool = ILoad
        load _ = ALoad
compileExpression (If p t e pos)
    = [LineNum pos.line, Branch (compileExpression p) (compileExpression t) (maybe [] compileExpression e)]
compileExpression (Typed _ expr)
    = compileExpression expr

compileFieldInit :: ClassName -> Field -> [Instruction]
compileFieldInit c (FieldCode{t,name,code}) = ALoad 0 : code ++ [PutField c name t]

compileField :: VarDeclaration -> Field
compileField (Var{name, varType, expr})
    = FieldCode
        { name = nameOf name
        , t = ttype varType
        , code = compileExpression expr
        }


compileVar :: VarDeclaration -> [Instruction]
compileVar (Var{name = Symbol _ (LocalSymbol _ i) t n, expr})
    = compileExpression expr ++ [store t i]
    where
        store TInt = IStore
        store TBool = IStore
        store _ = AStore

compileMethod :: MethodDeclaration -> MethodCode
compileMethod (MethodDeclaration{name,vars,exprs})
    = MethodCode (nameOf name) args vs ret
        (declareVars ++ (flattenInstructions_ $ concatMap compileExpression exprs) ++ [Return])
    where
        (Symbol i s (TMethod (args,ret)) p) = name
        vs = fmap (const 1) vars
        declareVars = concatMap compileVar vars

compileMain :: MainDeclaration -> Main
compileMain (Main{name, vars, body})
    = MainCode (nameOf name) (declareVars ++ (flattenInstructions_ $ concatMap compileExpression body) ++ [Return]) vs
    where
        declareVars = concatMap compileVar vars
        vs = (fmap (const 1) vars)

compileClass :: ClassDeclaration -> Class
compileClass (Class{name,extends,vars,methods})
    = ClassCode
        { name = nameOf name
        , extends = fmap nameOf extends
        , fields = fmap compileField vars
        , methods = fmap compileMethod methods
        }

compileProgram (Program classes main _)
    = ProgramCode (fmap compileClass classes, compileMain main)

