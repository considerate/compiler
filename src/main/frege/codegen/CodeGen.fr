module punkt0.codegen.CodeGen where
import punkt0.analyzer.Analyzer
import punkt0.parser.Grammar
import punkt0.Typed
import punkt0.Reporter
import Java.Util(LinkedList, List)
import Data.Traversable(traverse)

data Option a = pure native scala.Option {a} where
    pure native empty scala.Option.empty :: () -> Option a
    pure native apply scala.Option.apply :: a -> Option a

toOption :: Maybe a -> Option a
toOption Nothing = Option.empty ()
toOption (Just a) = Option.apply a

-- http://mmhelloworld.github.io/blog/2013/07/10/frege-hello-java/
-- Try: javap -cp lib/cafebabe_2.11-1.2.jar cafebabe.ClassFile
-- to see interface
-- can also run :javap -public cafebabe.ClassFile
-- in scala repl to see the information
data ClassFile = mutable native cafebabe.ClassFile where
    native new :: String -> Option String -> IO ClassFile
    native setSourceFile :: ClassFile -> String -> IO ()
    native writeToFile :: ClassFile -> String -> IO ()
    native addMainMethod :: ClassFile -> IO MethodHandler
    native addDefaultConstructor :: ClassFile -> IO ()
    native addField :: ClassFile -> String -> String -> IO FieldHandler
    native addConstructor :: ClassFile -> ScalaList String -> IO MethodHandler
    native addMethod :: ClassFile -> String -> String -> ScalaList String -> IO MethodHandler

data FieldHandler = mutable native cafebabe.FieldHandler

data MethodHandler = mutable native cafebabe.MethodHandler where
    native codeHandler :: MethodHandler -> IO CodeHandler

data ByteCode = pure native "cafebabe.AbstractByteCodes.AbstractByteCode"

data Function1 t r = pure native scala.Function1 {t,r}

type CodeGenerator = Function1 CodeHandler CodeHandler

data CodeHandler = mutable native cafebabe.CodeHandler where
    native append "$less$less" :: CodeHandler -> CodeGenerator -> IO CodeHandler
                                | CodeHandler -> ByteCode -> IO CodeHandler
    native freeze :: CodeHandler -> IO ()

-- https://github.com/psuter/cafebabe/blob/master/src/main/scala/cafebabe/AbstractByteCode.scala
data ScalaLineNumber = native "cafebabe.AbstractByteCodes$LineNumber$" where
    pure native apply "cafebabe.AbstractByteCodes.LineNumber$.MODULE$.apply" :: Int -> ByteCode

data ScalaALoad = native "cafebabe.AbstractByteCodes$ALoad$" where
    pure native apply "cafebabe.AbstractByteCodes.ALoad$.MODULE$.apply" :: Int -> CodeGenerator

data ScalaPush = native "cafebabe.AbstractByteCodes$Ldc$" where
    pure native apply "cafebabe.AbstractByteCodes.Ldc$.MODULE$.apply" :: String -> CodeGenerator
                                                                      | Int -> CodeGenerator

data ScalaGetStatic = native "cafebabe.AbstractByteCodes$GetStatic$" where
    pure native apply "cafebabe.AbstractByteCodes.GetStatic$.MODULE$.apply" :: String -> String -> String -> CodeGenerator

data ScalaInvoke = native "cafebabe.AbstractByteCodes$InvokeVirtual$" where
    pure native apply "cafebabe.AbstractByteCodes.InvokeVirtual$.MODULE$.apply" :: String -> String -> String -> CodeGenerator

data ScalaInvokeSpecial = native "cafebabe.AbstractByteCodes$InvokeSpecial$" where
    pure native apply "cafebabe.AbstractByteCodes.InvokeSpecial$.MODULE$.apply" :: String -> String -> String -> CodeGenerator

data ScalaNew = native "cafebabe.AbstractByteCodes$DefaultNew$" where
    pure native apply "cafebabe.AbstractByteCodes.DefaultNew$.MODULE$.apply" :: String -> CodeGenerator

data ScalaReturn = native "cafebabe.ByteCodes.RETURN$" where
    pure native o "cafebabe.ByteCodes.RETURN$.MODULE$" :: ByteCode

data ScalaIADD = native "cafebabe.ByteCodes.IADD$" where
    pure native o "cafebabe.ByteCodes.IADD$.MODULE$" :: ByteCode

data ScalaISUB = native "cafebabe.ByteCodes.ISUB$" where
    pure native o "cafebabe.ByteCodes.ISUB$.MODULE$" :: ByteCode

data ScalaIMUL = native "cafebabe.ByteCodes.IMUL$" where
    pure native o "cafebabe.ByteCodes.IMUL$.MODULE$" :: ByteCode

data ScalaIDIV = native "cafebabe.ByteCodes.IDIV$" where
    pure native o "cafebabe.ByteCodes.IDIV$.MODULE$" :: ByteCode

data ScalaIXOR = native "cafebabe.ByteCodes.IXOR$" where
    pure native o "cafebabe.ByteCodes.IXOR$.MODULE$" :: ByteCode

data ScalaList t = pure native scala.collection.immutable.List {t} where
    fromList xs = do
        l <- LinkedList.new ()
        l.addAllFromList xs
        b <- JavaConversions.asScalaBuffer l
        ScalaBuffer.toList b

data ScalaNil t = pure native scala.collection.immutable.Nil {t} where
    pure native nil "scala.collection.immutable.Nil$.MODULE$" :: ScalaList t

data ScalaBuffer t = native scala.collection.mutable.Buffer {t} where
    native toList :: Mutable s (ScalaBuffer t) -> ST s (ScalaList t)

data JavaConversions t = native scala.collection.JavaConversions {t} where
    native asScalaBuffer "scala.collection.JavaConversions.asScalaBuffer" :: Mutable s (List t) -> ST s (Mutable s (ScalaBuffer t))

javaType :: TType -> String
javaType (TMethod (args, ret)) = "(" ++ concat (fmap  javaType args) ++ ")" ++ javaType ret
javaType TString = "Ljava/lang/String;"
javaType TInt = "I"
javaType TBool = "Z"
javaType (TClass c) = "L" ++ c ++ ";"
javaType TUnit = "V"

data Gen
    = Gen CodeGenerator
    | Code ByteCode
getScalaI :: Instruction -> Gen
getScalaI (LineNum i) = Code $ ScalaLineNumber.apply i
getScalaI (ALoad i) = Gen $ ScalaALoad.apply i
getScalaI (Push i) = Gen $ ScalaPush.apply i
getScalaI (PushStr s) = Gen $ ScalaPush.apply s
getScalaI (GetStatic c m t) = Gen $ ScalaGetStatic.apply c m (javaType t)
getScalaI (Invoke c m t) = Gen $ ScalaInvoke.apply c m (javaType t)
getScalaI (InvokeSpecial c m t) = Gen $ ScalaInvokeSpecial.apply c m (javaType t)
getScalaI (DefaultNew c) = Gen $ ScalaNew.apply c
getScalaI Return = Code $ ScalaReturn.o
getScalaI IADD = Code $ ScalaIADD.o
getScalaI ISUB = Code $ ScalaISUB.o
getScalaI IMUL = Code $ ScalaIMUL.o
getScalaI IDIV = Code $ ScalaIDIV.o

buildCode :: CodeHandler -> [Instruction] -> IO CodeHandler
buildCode startHandler is = foldM f startHandler is
    where
        f handler i
            = case getScalaI i of
                Gen g -> handler.append g
                Code c -> handler.append c


testProgram
    = [ GetStatic "java/lang/System" "out" (TClass "java/io/PrintStream")
    , PushStr "Hello world!"
    , Invoke "java/io/PrintStream" "println" (TMethod ([TString], TUnit))
    , Return
    ]

compileExpression :: Expression -> [Instruction]
compileExpression (Typed TInt (BinOp (Typed TInt e1) op (Typed TInt e2) pos))
    = compileExpression e2 ++ compileExpression e1 ++ case op of
        Plus -> [LineNum pos.line, IADD]
        Minus -> [LineNum pos.line, ISUB]
        Times -> [LineNum pos.line, IMUL]
        Div -> [LineNum pos.line, IDIV]
compileExpression (Println (Typed t expr) _)
    = [GetStatic "java/lang/System" "out" (TClass "java/io/PrintStream")]
        ++ compileExpression (Typed t expr)
        ++ [Invoke "java/io/PrintStream" "println" (TMethod ([t],TUnit))]
compileExpression (MethodCall (Typed (TClass classType) c) (Symbol _ _ mtype method) args _)
    = compileExpression c ++ concatMap compileExpression args ++ [Invoke classType (nameOf method) mtype]
compileExpression (New (Symbol _ _ (TClass classType) obj) _)
    = [DefaultNew classType]
compileExpression (LitInt i _) = [Push i]
compileExpression (LitString s _) = [PushStr s]
compileExpression (LitFalse _) = [IConst 0]
compileExpression (LitTrue _) = [IConst 1]
compileExpression (Typed _ expr)
    | otherwise = compileExpression expr

compileMethod :: MethodDeclaration -> MethodCode
compileMethod (MethodDeclaration{name,vars,exprs})
    = MethodCode (nameOf name) args ret (declareVars ++ concatMap compileExpression exprs ++ [Return])
    where
        (Symbol i s (TMethod (args,ret)) p) = name
        declareVars = []

compileMain :: MainDeclaration -> Main
compileMain (Main{name, vars, body})
    = MainCode (nameOf name) (concatMap compileExpression body ++ [Return])

compileClass :: ClassDeclaration -> Class
compileClass (Class{name,extends,vars,methods})
    = ClassCode
        { name = nameOf name
        , extends = fmap nameOf extends
        , fields = []
        , methods = fmap compileMethod methods
        }

compileProgram (Program classes main _)
    = ProgramCode (fmap compileClass classes, compileMain main)

buildField :: ClassName -> Field -> [Instruction]
buildField c (FieldCode{t,name,code}) = code ++ [PutField c name t]

buildMethod :: ClassName -> ClassFile -> MethodCode -> IO ClassFile
buildMethod className cf (MethodCode{name,args,returnType,body})
    = ScalaList.fromList argTypes >>= \types ->
    cf.addMethod (javaType returnType) name types >>= \methodHandler ->
    methodHandler.codeHandler >>= \codeHandler ->
    buildCode codeHandler body >>= \_ ->
    codeHandler.freeze >>= \_ ->
    pure cf
    where
        argTypes = fmap javaType args

buildClass :: Class -> IO ()
buildClass (ClassCode{name,extends,fields,methods})
    = ClassFile.new name (toOption extends) >>= \cf ->
    cf.setSourceFile "HW.java" >>= \_ ->
    cf.addConstructor (ScalaNil.nil) >>= \mm ->
    mm.codeHandler >>= \code ->
    buildCode code constructor >>= \_ ->
    code.freeze >>= \_ ->
    foldM (buildMethod name) cf methods >>= \cf' ->
    cf'.writeToFile (name ++ ".class")
    where
        super = fromMaybe "java/lang/Object" extends
        thisPtr = ALoad 0
        construct = InvokeSpecial super "<init>" (TMethod ([],TUnit))
        constructor = thisPtr : construct : concatMap (buildField name) fields ++ [Return]

testCafe :: Prog -> IO ()
testCafe (ProgramCode (classes, MainCode{name,body}))
    = traverse buildClass classes
    >>= \_ -> ClassFile.new name (toOption Nothing)
    >>= \cf -> cf.setSourceFile "HW.java"
    >>= \_ -> cf.addDefaultConstructor
    >>= \_ -> cf.addMainMethod
    >>= \mm -> mm.codeHandler
    >>= \code -> buildCode code body
    >>= \_ -> code.freeze
    >>= \_ -> cf.writeToFile (name ++ ".class")

testCode = "class A{def foo() : Unit = {println(\"Hello, World!\")}} object Main extends App {new A().foo()}"
-- testCode = "object Main extends App { println(\"Hello, Dear World!\")}"
--testCode = "object Main extends App {println(1+3/2*4)}"
--testCode = "object Main extends App {println(1+3)}"
main = let
        (Just ast) = parseCode program testCode
        -- Left errors = analyzer ast
        (Right ast') = analyzer ast
        prog = compileProgram ast'
    in print ast'
    >> testCafe prog

type ClassName = String
type QualifiedClass = String
type FieldName = String
type Method = String
type VarId = Int

data Instruction
    = LineNum Int
    | Return
    | Push Int
    | PushStr String
    | IConst Int
    | ILoad VarId
    | ALoad VarId
    | IStore VarId
    | AStore VarId
    | IADD
    | ISUB
    | IMUL
    | IDIV
    | IXOR
    | StringAppend (TType, [Instruction]) (TType, [Instruction])
    | Invoke QualifiedClass String TType
    | InvokeSpecial QualifiedClass String TType
    | DefaultNew QualifiedClass
    | GetStatic QualifiedClass FieldName TType
    | PutField QualifiedClass FieldName TType
    | Branch
        { pred :: [Instruction]
        , thenBody :: [Instruction]
        , elseBody :: [Instruction]
        }
    | Loop
        { pred :: [Instruction]
        , body :: [Instruction]
        }
derive Show Instruction

data Field
    = FieldCode
        { t :: TType
        , name :: FieldName
        , code :: [Instruction]
        }

data MethodCode
    = MethodCode
        { name :: String
        , args :: [TType]
        , returnType :: TType
        , body :: [Instruction]
        }

data Class
    = ClassCode
        { name :: ClassName
        , extends :: Maybe QualifiedClass
        , fields :: [Field]
        , methods :: [MethodCode]
        }

data Main
    = MainCode
        { name :: ClassName
        , body :: [Instruction]
        }

data Prog
    = ProgramCode ([Class], Main)
