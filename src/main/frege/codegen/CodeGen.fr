module punkt0.codegen.CodeGen where
import punkt0.parser.Grammar
import punkt0.Typed

data Option a = pure native scala.Option {a} where
    pure native empty scala.Option.empty :: () -> Option a
    pure native apply scala.Option.apply :: a -> Option a

toOption :: Maybe a -> Option a
toOption Nothing = Option.empty ()
toOption (Just a) = Option.apply a

-- http://mmhelloworld.github.io/blog/2013/07/10/frege-hello-java/
-- Try: javap -cp lib/cafebabe_2.11-1.2.jar cafebabe.ClassFile
-- to see interface
-- can also run :javap -public cafebabe.ClassFile
-- in scala repl to see the information
data ClassFile = mutable native cafebabe.ClassFile where
    native new :: String -> Option String -> IO ClassFile
    native setSourceFile :: ClassFile -> String -> IO ()
    native writeToFile :: ClassFile -> String -> IO ()
    native addMainMethod :: ClassFile -> IO MethodHandler
    native addDefaultConstructor :: ClassFile -> IO ()

-- data Codes = native p0scala.codegen.Codes

-- public class cafebabe.MethodHandler {
--   public cafebabe.CodeHandler codeHandler();
--   public void setFlags(short);
--   public cafebabe.MethodHandler(cafebabe.MethodInfo, cafebabe.CodeAttributeInfo, cafebabe.ConstantPool, java.lang.String);
-- }
data MethodHandler = mutable native cafebabe.MethodHandler where
    native codeHandler :: MethodHandler -> IO CodeHandler

-- public class cafebabe.CodeHandler {
--   public java.lang.String paramTypes();
--   public boolean isStatic();
--   public cafebabe.CodeAttributeInfo cafebabe$CodeHandler$$code();
--   public cafebabe.ConstantPool constantPool();
--   public boolean isFrozen();
--   public cafebabe.CodeHandler $less$less(scala.Function1<cafebabe.CodeHandler, cafebabe.CodeHandler>);
--   public cafebabe.CodeHandler $less$less(cafebabe.AbstractByteCodes$AbstractByteCode);
--   public scala.collection.immutable.Map<java.lang.Object, scala.Tuple2<java.lang.String, java.lang.Object>> argSlotMap();
--   public int getFreshVar();
--   public int getFreshVar(java.lang.String);
--   public int getFreshVar(int);
--   public void freeVar(int);
--   public scala.collection.mutable.HashMap<java.lang.String, java.lang.Object> cafebabe$CodeHandler$$labelCounts();
--   public java.lang.String getFreshLabel(java.lang.String);
--   public void freeze();
--   public short computeMaxStack(scala.collection.immutable.List<cafebabe.AbstractByteCodes$AbstractByteCode>);
--   public void print();
--   public cafebabe.CodeHandler(cafebabe.CodeAttributeInfo, cafebabe.ConstantPool, java.lang.String, boolean);
-- }


data ByteCode = pure native "cafebabe.AbstractByteCodes.AbstractByteCode"

data Function1 t r = pure native scala.Function1 {t,r}

type CodeGenerator = Function1 CodeHandler CodeHandler

data CodeHandler = mutable native cafebabe.CodeHandler where
    native append "$less$less" :: CodeHandler -> CodeGenerator -> IO CodeHandler
                                | CodeHandler -> ByteCode -> IO CodeHandler
    native freeze :: CodeHandler -> IO ()

-- https://github.com/psuter/cafebabe/blob/master/src/main/scala/cafebabe/AbstractByteCode.scala
data ScalaALoad = native "cafebabe.AbstractByteCodes$ALoad$" where
    pure native apply "cafebabe.AbstractByteCodes.ALoad$.MODULE$.apply" :: Int -> CodeGenerator

data ScalaPush = native "cafebabe.AbstractByteCodes$Ldc$" where
    pure native apply "cafebabe.AbstractByteCodes.Ldc$.MODULE$.apply" :: String -> CodeGenerator
                                                                      | Int -> CodeGenerator

data ScalaGetStatic = native "cafebabe.AbstractByteCodes$GetStatic$" where
    pure native apply "cafebabe.AbstractByteCodes.GetStatic$.MODULE$.apply" :: String -> String -> String -> CodeGenerator

data ScalaInvoke = native "cafebabe.AbstractByteCodes$InvokeVirtual$" where
    pure native apply "cafebabe.AbstractByteCodes.InvokeVirtual$.MODULE$.apply" :: String -> String -> String -> CodeGenerator

data ScalaReturn = native "cafebabe.ByteCodes.RETURN$" where
    pure native o "cafebabe.ByteCodes.RETURN$.MODULE$" :: ByteCode

javaType :: TType -> String
javaType (TMethod (args, ret)) = "(" ++ concat (fmap  javaType args) ++ ")" ++ javaType ret
javaType TString = "Ljava/lang/String;"
javaType TInt = "I"
javaType TBool = "Z"
javaType (TClass c) = "L" ++ c ++ ";"
javaType TUnit = "V"

data Gen
    = Gen CodeGenerator
    | Code ByteCode
getScalaI :: Instruction -> IO Gen
getScalaI (Push i) = pure $ Gen $ ScalaPush.apply i
getScalaI (PushStr s) = pure $ Gen $ ScalaPush.apply s
getScalaI (GetStatic c m t) = pure $ Gen $ ScalaGetStatic.apply c m (javaType t)
getScalaI (Invoke c m t) = pure $ Gen $ ScalaInvoke.apply c m (javaType t)
getScalaI Return = pure $ Code $ ScalaReturn.o

buildCode :: CodeHandler -> [Instruction] -> IO CodeHandler
buildCode startHandler is = foldM f startHandler is
    where
        f handler i
            = getScalaI i
            >>= \res -> case res of
                Gen g -> handler.append g
                Code c -> handler.append c


testProgram
    = [ GetStatic "java/lang/System" "out" (TClass "java/io/PrintStream")
    , PushStr "Hello world!"
    , Invoke "java/io/PrintStream" "println" (TMethod ([TString], TUnit))
    , Return
    ]

testCafe :: IO ()
testCafe = ClassFile.new "HW" (toOption Nothing)
    >>= \cf -> cf.setSourceFile "HW.java"
    >>= \_ -> cf.addDefaultConstructor
    >>= \_ -> cf.addMainMethod
    >>= \mm -> mm.codeHandler
    >>= \code -> buildCode code testProgram
    >>= \_ -> code.freeze
    >>= \_ -> cf.writeToFile "HW.class"

main = testCafe

type ClassName = String
type QualifiedClass = String
type FieldName = String
type Method = String
type VarId = Int

data Instruction
    = LineNum Int
    | Return
    | Push Int
    | PushStr String
    | IConst Int
    | ILoad VarId
    | ALoad VarId
    | IStore VarId
    | AStore VarId
    | IAdd
    | StringAppend (TType, [Instruction]) (TType, [Instruction])
    | Invoke QualifiedClass Method TType
    | DefaultNew QualifiedClass
    | GetStatic QualifiedClass FieldName TType
    | Branch
        { pred :: [Instruction]
        , thenBody :: [Instruction]
        , elseBody :: [Instruction]
        }
    | Loop
        { pred :: [Instruction]
        , body :: [Instruction]
        }

data Field
    = FieldCode
        { t :: TType
        , name :: FieldName
        , code :: [Instruction]
        }

data Class
    = ClassCode
        { name :: ClassName
        , extends :: Maybe QualifiedClass
        , fields :: [Field]
        , methods :: [Method]
        }

{-
compileProgram :: Program -> [Instruction]
compileProgram (Program classes main _)
    = concatMap compileClass classes ++ compileMain main

compileMain :: MainDeclaration -> [Instruction]
compileMain = undefined

compileClass :: ClassDeclaration -> [Instruction]
compileClass = undefined

-- Compile local var
compileVar :: VarDeclaration -> [Instruction]
compileVar (Var (Symbol _ (LocalSymbol _ i) TInt _) _ expr _)
    = compileExpression expr ++ [IStore i]
compileVar (Var (Symbol _ (LocalSymbol _ i) TBool _) _ expr _)
    = compileExpression expr ++ [IStore i]
compileVar (Var (Symbol i (LocalSymbol _ i) (TClass c) _) _ expr _)
    = compileExpression expr ++ [AStore i]
compileVar (Var (Symbol i (LocalSymbol _ i) TString _) _ expr _)
    = compileExpression expr ++ [AStore i]
compileVar v
    = error ("Internal error: " ++ show v ++ " is not a local var")

compileExpression :: Expression -> [Instruction]
compileExpression (Typed TInt (Identifier (Symbol i _ _) _)) = ILoad i
compileExpression (Typed TString (Identifier (Symbol i _ _) _)) = ALoad i
compileExpression (Typed TInt (BinOp ((Typed TInt e1) Add (Typed TInt e2 _)) _))
    = compileExpression e2 ++ compileExpression e1 ++ [IAdd]
compileExpression (TypedExpr TString (BinOp ((TypedExpr t1 e1) Add (TypedExpr t2 e2 _)) _))
    = StringAppend (t1, (compileExpression e1)) (t2, (compileExpression e2))
compileExpression (TypedExpr returnType (MethodCall c method args _))
    = compileExpression c ++ fmap compileExpression args ++ [Invoke classType method returnType]
compileExpression (TypedExpr (TClass classType _) (New obj _))
    = [DefaultNew classType]
compileExpression (TypedExpr _ expr)
    = compileExpression expr
compileExpression (Println (Typed t expr))
    = [GetStatic "java/lang/System" "out" (TClass "java/io/PrintStream" empty)]
    ++ compileExpression expr
    ++ [Invoke "java/io/PrintStream" "println" t]
compileExpression (LitInt i _) = [Push i]
-- compileExpression (LitString s _) = [SLoad s]
compileExpression (LitFalse _) = [IConst 0]
compileExpression (LitTrue _) = [IConst 1]
-}
