module punkt0.codegen.CodeGen where
import punkt0.analyzer.Analyzer
import punkt0.parser.Grammar
import punkt0.Typed
import punkt0.Reporter

data Option a = pure native scala.Option {a} where
    pure native empty scala.Option.empty :: () -> Option a
    pure native apply scala.Option.apply :: a -> Option a

toOption :: Maybe a -> Option a
toOption Nothing = Option.empty ()
toOption (Just a) = Option.apply a

-- http://mmhelloworld.github.io/blog/2013/07/10/frege-hello-java/
-- Try: javap -cp lib/cafebabe_2.11-1.2.jar cafebabe.ClassFile
-- to see interface
-- can also run :javap -public cafebabe.ClassFile
-- in scala repl to see the information
data ClassFile = mutable native cafebabe.ClassFile where
    native new :: String -> Option String -> IO ClassFile
    native setSourceFile :: ClassFile -> String -> IO ()
    native writeToFile :: ClassFile -> String -> IO ()
    native addMainMethod :: ClassFile -> IO MethodHandler
    native addDefaultConstructor :: ClassFile -> IO ()

data MethodHandler = mutable native cafebabe.MethodHandler where
    native codeHandler :: MethodHandler -> IO CodeHandler

data ByteCode = pure native "cafebabe.AbstractByteCodes.AbstractByteCode"

data Function1 t r = pure native scala.Function1 {t,r}

type CodeGenerator = Function1 CodeHandler CodeHandler

data CodeHandler = mutable native cafebabe.CodeHandler where
    native append "$less$less" :: CodeHandler -> CodeGenerator -> IO CodeHandler
                                | CodeHandler -> ByteCode -> IO CodeHandler
    native freeze :: CodeHandler -> IO ()

-- https://github.com/psuter/cafebabe/blob/master/src/main/scala/cafebabe/AbstractByteCode.scala
data ScalaALoad = native "cafebabe.AbstractByteCodes$ALoad$" where
    pure native apply "cafebabe.AbstractByteCodes.ALoad$.MODULE$.apply" :: Int -> CodeGenerator

data ScalaPush = native "cafebabe.AbstractByteCodes$Ldc$" where
    pure native apply "cafebabe.AbstractByteCodes.Ldc$.MODULE$.apply" :: String -> CodeGenerator
                                                                      | Int -> CodeGenerator

data ScalaGetStatic = native "cafebabe.AbstractByteCodes$GetStatic$" where
    pure native apply "cafebabe.AbstractByteCodes.GetStatic$.MODULE$.apply" :: String -> String -> String -> CodeGenerator

data ScalaInvoke = native "cafebabe.AbstractByteCodes$InvokeVirtual$" where
    pure native apply "cafebabe.AbstractByteCodes.InvokeVirtual$.MODULE$.apply" :: String -> String -> String -> CodeGenerator

data ScalaReturn = native "cafebabe.ByteCodes.RETURN$" where
    pure native o "cafebabe.ByteCodes.RETURN$.MODULE$" :: ByteCode

data ScalaIADD = native "cafebabe.ByteCodes.IADD$" where
    pure native o "cafebabe.ByteCodes.IADD$.MODULE$" :: ByteCode

data ScalaISUB = native "cafebabe.ByteCodes.ISUB$" where
    pure native o "cafebabe.ByteCodes.ISUB$.MODULE$" :: ByteCode

data ScalaIMUL = native "cafebabe.ByteCodes.IMUL$" where
    pure native o "cafebabe.ByteCodes.IMUL$.MODULE$" :: ByteCode

data ScalaIDIV = native "cafebabe.ByteCodes.IDIV$" where
    pure native o "cafebabe.ByteCodes.IDIV$.MODULE$" :: ByteCode

data ScalaIXOR = native "cafebabe.ByteCodes.IXOR$" where
    pure native o "cafebabe.ByteCodes.IXOR$.MODULE$" :: ByteCode



javaType :: TType -> String
javaType (TMethod (args, ret)) = "(" ++ concat (fmap  javaType args) ++ ")" ++ javaType ret
javaType TString = "Ljava/lang/String;"
javaType TInt = "I"
javaType TBool = "Z"
javaType (TClass c) = "L" ++ c ++ ";"
javaType TUnit = "V"

data Gen
    = Gen CodeGenerator
    | Code ByteCode
getScalaI :: Instruction -> Gen
getScalaI (Push i) = Gen $ ScalaPush.apply i
getScalaI (PushStr s) = Gen $ ScalaPush.apply s
getScalaI (GetStatic c m t) = Gen $ ScalaGetStatic.apply c m (javaType t)
getScalaI (Invoke c m t) = Gen $ ScalaInvoke.apply c m (javaType t)
getScalaI Return = Code $ ScalaReturn.o
getScalaI IADD = Code $ ScalaIADD.o
getScalaI ISUB = Code $ ScalaISUB.o
getScalaI IMUL = Code $ ScalaIMUL.o
getScalaI IDIV = Code $ ScalaIDIV.o

buildCode :: CodeHandler -> [Instruction] -> IO CodeHandler
buildCode startHandler is = foldM f startHandler is
    where
        f handler i
            = case getScalaI i of
                Gen g -> handler.append g
                Code c -> handler.append c


testProgram
    = [ GetStatic "java/lang/System" "out" (TClass "java/io/PrintStream")
    , PushStr "Hello world!"
    , Invoke "java/io/PrintStream" "println" (TMethod ([TString], TUnit))
    , Return
    ]

compileExpression :: Expression -> [Instruction]
compileExpression (Typed TInt (BinOp (Typed TInt e1) op (Typed TInt e2) pos))
    = compileExpression e2 ++ compileExpression e1 ++ case op of
        Plus -> [LineNum pos.line, IADD]
        Minus -> [LineNum pos.line, ISUB]
        Times -> [LineNum pos.line, IMUL]
        Div -> [LineNum pos.line, IDIV]
compileExpression (Typed _ expr)
    | traceLn (show expr) = undefined
    | otherwise = compileExpression expr
--compileExpression (If pred body Nothing pos)

{-
compileExpression (Typed TBool (BinOp e1 op e2 pos)) = case (e1.t,e2.t) of
    (TInt,TInt) -> compileExpression e2 ++ compileExpression e1 ++ case op of
        Equals -> _
        LessThan -> _
    (TBool,TBool) -> compileExpression e2 ++ compileExpression e1 ++ case op of
        Equals -> 

    (TString,TString) -> undefined
    _ -> compileExpression e2 ++ compileExpression e1




    (TString,TInt) -> undefined
    (TInt,TString) -> undefined
    (TBool,TBool) -> compileExpression e2 ++ compileExpression e1 ++ case op of
        And -> undefined
        Or -> undefined
        Equals -> undefined
    (TUnit,_) -> error "Bad Type."
    (TMethod _,_) -> error "Bad Type."
    (_,TUnit) -> error "Bad Type."
    (_,TMethod _) -> error "Bad Type."
-}


compileExpression (Println (Typed t expr) _)
    = [GetStatic "java/lang/System" "out" (TClass "java/io/PrintStream")]
        ++ compileExpression (Typed t expr)
        ++ [Invoke "java/io/PrintStream" "println" (TMethod ([t],TUnit))]
compileExpression (LitInt i _) = [Push i]
compileExpression (LitString s _) = [PushStr s]
compileExpression (LitFalse _) = [IConst 0]
compileExpression (LitTrue _) = [IConst 1]

compileMain :: MainDeclaration -> [Instruction]
compileMain (Main{vars,body})
    = concatMap compileExpression body ++ [Return]

compileClass :: ClassDeclaration -> [Instruction]
compileClass = undefined

compileProgram :: Program -> [Instruction]
compileProgram (Program classes main _)
    = concatMap compileClass classes ++ compileMain main

testCafe :: [Instruction] -> IO ()
testCafe inst = ClassFile.new "HW" (toOption Nothing)
    >>= \cf -> cf.setSourceFile "HW.java"
    >>= \_ -> cf.addDefaultConstructor
    >>= \_ -> cf.addMainMethod
    >>= \mm -> mm.codeHandler
    >>= \code -> buildCode code inst
    >>= \_ -> code.freeze
    >>= \_ -> cf.writeToFile "HW.class"

-- testCode = "class A{def foo() : Unit = {println(\"Hello, World!\")}} object Main extends App {new A().foo()}"
-- testCode = "object Main extends App { println(\"Hello, Dear World!\")}"
--testCode = "object Main extends App {println(1+3/2*4)}"
testCode = "object Main extends App {println(1+3)}"
main = let
        (Just ast) = parseCode program testCode
        (Right ast') = analyzer ast
        prog = compileProgram ast'
    in print ast'
    >> testCafe prog

type ClassName = String
type QualifiedClass = String
type FieldName = String
type Method = String
type VarId = Int

data Instruction
    = LineNum Int
    | Return
    | Push Int
    | PushStr String
    | IConst Int
    | ILoad VarId
    | ALoad VarId
    | IStore VarId
    | AStore VarId
    | IADD
    | ISUB
    | IMUL
    | IDIV
    | IXOR
    | StringAppend (TType, [Instruction]) (TType, [Instruction])
    | Invoke QualifiedClass Method TType
    | DefaultNew QualifiedClass
    | GetStatic QualifiedClass FieldName TType
    | Branch
        { pred :: [Instruction]
        , thenBody :: [Instruction]
        , elseBody :: [Instruction]
        }
    | Loop
        { pred :: [Instruction]
        , body :: [Instruction]
        }
derive Show Instruction

data Field
    = FieldCode
        { t :: TType
        , name :: FieldName
        , code :: [Instruction]
        }

data Class
    = ClassCode
        { name :: ClassName
        , extends :: Maybe QualifiedClass
        , fields :: [Field]
        , methods :: [Method]
        }

{-

-- Compile local var
compileVar :: VarDeclaration -> [Instruction]
compileVar (Var (Symbol _ (LocalSymbol _ i) TInt _) _ expr _)
    = compileExpression expr ++ [IStore i]
compileVar (Var (Symbol _ (LocalSymbol _ i) TBool _) _ expr _)
    = compileExpression expr ++ [IStore i]
compileVar (Var (Symbol i (LocalSymbol _ i) (TClass c) _) _ expr _)
    = compileExpression expr ++ [AStore i]
compileVar (Var (Symbol i (LocalSymbol _ i) TString _) _ expr _)
    = compileExpression expr ++ [AStore i]
compileVar v
    = error ("Internal error: " ++ show v ++ " is not a local var")

-}
