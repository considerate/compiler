module punkt0.codegen.CodeGen where
import punkt0.analyzer.Analyzer
import punkt0.parser.Grammar
import punkt0.Typed
import punkt0.Reporter

data Option a = pure native scala.Option {a} where
    pure native empty scala.Option.empty :: () -> Option a
    pure native apply scala.Option.apply :: a -> Option a

toOption :: Maybe a -> Option a
toOption Nothing = Option.empty ()
toOption (Just a) = Option.apply a

-- http://mmhelloworld.github.io/blog/2013/07/10/frege-hello-java/
-- Try: javap -cp lib/cafebabe_2.11-1.2.jar cafebabe.ClassFile
-- to see interface
-- can also run :javap -public cafebabe.ClassFile
-- in scala repl to see the information
data ClassFile = mutable native cafebabe.ClassFile where
    native new :: String -> Option String -> IO ClassFile
    native setSourceFile :: ClassFile -> String -> IO ()
    native writeToFile :: ClassFile -> String -> IO ()
    native addMainMethod :: ClassFile -> IO MethodHandler
    native addDefaultConstructor :: ClassFile -> IO ()

data MethodHandler = mutable native cafebabe.MethodHandler where
    native codeHandler :: MethodHandler -> IO CodeHandler

data ByteCode = pure native "cafebabe.AbstractByteCodes.AbstractByteCode"

data Function1 t r = pure native scala.Function1 {t,r}

type CodeGenerator = Function1 CodeHandler CodeHandler

data CodeHandler = mutable native cafebabe.CodeHandler where
    native append "$less$less" :: CodeHandler -> CodeGenerator -> IO CodeHandler
                                | CodeHandler -> ByteCode -> IO CodeHandler
    native freeze :: CodeHandler -> IO ()

-- https://github.com/psuter/cafebabe/blob/master/src/main/scala/cafebabe/AbstractByteCode.scala
data ScalaALoad = native "cafebabe.AbstractByteCodes$ALoad$" where
    pure native apply "cafebabe.AbstractByteCodes.ALoad$.MODULE$.apply" :: Int -> CodeGenerator

data ScalaPush = native "cafebabe.AbstractByteCodes$Ldc$" where
    pure native apply "cafebabe.AbstractByteCodes.Ldc$.MODULE$.apply" :: String -> CodeGenerator
                                                                      | Int -> CodeGenerator

data ScalaGetStatic = native "cafebabe.AbstractByteCodes$GetStatic$" where
    pure native apply "cafebabe.AbstractByteCodes.GetStatic$.MODULE$.apply" :: String -> String -> String -> CodeGenerator

data ScalaInvoke = native "cafebabe.AbstractByteCodes$InvokeVirtual$" where
    pure native apply "cafebabe.AbstractByteCodes.InvokeVirtual$.MODULE$.apply" :: String -> String -> String -> CodeGenerator

data ScalaReturn = native "cafebabe.ByteCodes.RETURN$" where
    pure native o "cafebabe.ByteCodes.RETURN$.MODULE$" :: ByteCode

javaType :: TType -> String
javaType (TMethod (args, ret)) = "(" ++ concat (fmap  javaType args) ++ ")" ++ javaType ret
javaType TString = "Ljava/lang/String;"
javaType TInt = "I"
javaType TBool = "Z"
javaType (TClass c) = "L" ++ c ++ ";"
javaType TUnit = "V"

data Gen
    = Gen CodeGenerator
    | Code ByteCode
getScalaI :: Instruction -> IO Gen
getScalaI (Push i) = pure $ Gen $ ScalaPush.apply i
getScalaI (PushStr s) = pure $ Gen $ ScalaPush.apply s
getScalaI (GetStatic c m t) = pure $ Gen $ ScalaGetStatic.apply c m (javaType t)
getScalaI (Invoke c m t) = pure $ Gen $ ScalaInvoke.apply c m (javaType t)
getScalaI Return = pure $ Code $ ScalaReturn.o

buildCode :: CodeHandler -> [Instruction] -> IO CodeHandler
buildCode startHandler is = foldM f startHandler is
    where
        f handler i
            = getScalaI i
            >>= \res -> case res of
                Gen g -> handler.append g
                Code c -> handler.append c


testProgram
    = [ GetStatic "java/lang/System" "out" (TClass "java/io/PrintStream")
    , PushStr "Hello world!"
    , Invoke "java/io/PrintStream" "println" (TMethod ([TString], TUnit))
    , Return
    ]


compileExpression :: Expression -> [Instruction]
{-
compileExpression (Typed TInt (Identifier (Symbol i _ _) _)) = ILoad i
compileExpression (Typed TString (Identifier (Symbol i _ _) _)) = ALoad i
compileExpression (Typed TInt (BinOp ((Typed TInt e1) Add (Typed TInt e2 _)) _))
    = compileExpression e2 ++ compileExpression e1 ++ [IAdd]
compileExpression (TypedExpr TString (BinOp ((TypedExpr t1 e1) Add (TypedExpr t2 e2 _)) _))
    = StringAppend (t1, (compileExpression e1)) (t2, (compileExpression e2))
compileExpression (TypedExpr returnType (MethodCall c method args _))
    = compileExpression c ++ fmap compileExpression args ++ [Invoke classType method returnType]
compileExpression (TypedExpr (TClass classType _) (New obj _))
    = [DefaultNew classType]
compileExpression (TypedExpr _ expr)
    = compileExpression expr
-}
compileExpression (Typed _ expr)
    = compileExpression expr
compileExpression (Println (Typed t expr) _)
    = [GetStatic "java/lang/System" "out" (TClass "java/io/PrintStream")]
        ++ compileExpression expr
        ++ [Invoke "java/io/PrintStream" "println" (TMethod ([t],TUnit))]
compileExpression (LitInt i _) = [Push i]
compileExpression (LitString s _) = [PushStr s]
compileExpression (LitFalse _) = [IConst 0]
compileExpression (LitTrue _) = [IConst 1]

compileMain :: MainDeclaration -> [Instruction]
compileMain (Main{vars,body})
    = concatMap compileExpression body ++ [Return]

compileClass :: ClassDeclaration -> [Instruction]
compileClass = undefined

compileProgram :: Program -> [Instruction]
compileProgram (Program classes main _)
    = concatMap compileClass classes ++ compileMain main

testCode = "object Main extends App {println(\"Hello, World!\")}"
go = let
        (Just ast) = parseCode program testCode
        (Right ast') = analyzer ast
    in compileProgram ast'

testCafe :: [Instruction] -> IO ()
testCafe inst = ClassFile.new "HW" (toOption Nothing)
    >>= \cf -> cf.setSourceFile "HW.java"
    >>= \_ -> cf.addDefaultConstructor
    >>= \_ -> cf.addMainMethod
    >>= \mm -> mm.codeHandler
    >>= \code -> buildCode code inst
    >>= \_ -> code.freeze
    >>= \_ -> cf.writeToFile "HW.class"

main = testCafe go

type ClassName = String
type QualifiedClass = String
type FieldName = String
type Method = String
type VarId = Int

data Instruction
    = LineNum Int
    | Return
    | Push Int
    | PushStr String
    | IConst Int
    | ILoad VarId
    | ALoad VarId
    | IStore VarId
    | AStore VarId
    | IAdd
    | StringAppend (TType, [Instruction]) (TType, [Instruction])
    | Invoke QualifiedClass Method TType
    | DefaultNew QualifiedClass
    | GetStatic QualifiedClass FieldName TType
    | Branch
        { pred :: [Instruction]
        , thenBody :: [Instruction]
        , elseBody :: [Instruction]
        }
    | Loop
        { pred :: [Instruction]
        , body :: [Instruction]
        }
derive Show Instruction

data Field
    = FieldCode
        { t :: TType
        , name :: FieldName
        , code :: [Instruction]
        }

data Class
    = ClassCode
        { name :: ClassName
        , extends :: Maybe QualifiedClass
        , fields :: [Field]
        , methods :: [Method]
        }

{-

-- Compile local var
compileVar :: VarDeclaration -> [Instruction]
compileVar (Var (Symbol _ (LocalSymbol _ i) TInt _) _ expr _)
    = compileExpression expr ++ [IStore i]
compileVar (Var (Symbol _ (LocalSymbol _ i) TBool _) _ expr _)
    = compileExpression expr ++ [IStore i]
compileVar (Var (Symbol i (LocalSymbol _ i) (TClass c) _) _ expr _)
    = compileExpression expr ++ [AStore i]
compileVar (Var (Symbol i (LocalSymbol _ i) TString _) _ expr _)
    = compileExpression expr ++ [AStore i]
compileVar v
    = error ("Internal error: " ++ show v ++ " is not a local var")

-}
