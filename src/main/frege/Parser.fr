module Parser where
import frege.Prelude hiding (Reader, runReader)

data Reader r a = Reader (r -> a)

instance Functor (Reader r) where
    fmap f (Reader g) = Reader (f • g)

instance Applicative (Reader r) where
    Reader f <*> Reader x = Reader (\r -> (f r) (x r))
    pure = Reader • const

runReader :: Reader r a -> (r -> a)
runReader (Reader f) = f

instance Monad (Reader r) where
    m >>= g = join $ fmap g m
    join (Reader g) = Reader (\r -> (runReader • g) r r)
    pure = Reader • const

data State s a = State (s -> (s, a))

instance Functor (State s) where
    fmap f (State g) = State (\s -> (fmap f . g) s)

instance Applicative (State s) where
    State fs <*> State xs = State $ \s ->
        let
            (s', f) = fs s
            (s'', a) = xs s'
        in (s'', f a)
    pure x = State (\s -> (s, x))

instance Monad (State s) where
    (State f) >>= g = State $ \s ->
        let (s', a) = f s
            State h = g a
        in h s'
    pure x = State (\s -> (s, x))

data Parser token result = Parser { run :: [token] -> [([token], result)]}

instance Functor (Parser token) where
    fmap f p = Parser (fmap (fmap f) • p.run)

instance Applicative (Parser token) where
    fparser <*> xparser = Parser $ \(tokens) ->
        [(tokens'', f x) |
            (tokens', f) <- fparser.run tokens,
            (tokens'', x) <- xparser.run tokens']
    pure x = Parser (\tokens -> [(tokens, x)])

instance Monad (Parser token) where
    pure x = Parser (\tokens -> [(tokens, x)])
    aparser >>= f = Parser $ \tokens ->
        [(tokens'', b) |
            (tokens', a) <- aparser.run tokens,
            (tokens'', b) <- (f a).run tokens']

satisfy :: (token -> Bool) -> Parser token token
satisfy predicate = Parser $ \tokens ->
    case tokens of
        [] -> []
        (t:rest) -> if predicate t
            then [(rest,t)]
            else []

item :: Parser token token
item = satisfy (const true)

