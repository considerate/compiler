module parser.Parser where

data Parser token result = Parser { run :: [token] -> [([token], result)]}

parse :: Parser token result -> [token] -> [([token], result)]
parse parser = parser.run

instance Functor (Parser token) where
    fmap f p = Parser (fmap (fmap f) â€¢ p.run)

instance Applicative (Parser token) where
    fparser <*> xparser = Parser $ \tokens ->
        [(tokens'', f x) |
            (tokens', f) <- fparser.run tokens,
            (tokens'', x) <- xparser.run tokens']
    pure x = Parser (\tokens -> [(tokens, x)])

instance Monad (Parser token) where
    pure x = Parser (\tokens -> [(tokens, x)])
    aparser >>= f = Parser $ \tokens ->
        [(tokens'', b) |
            (tokens', a) <- aparser.run tokens,
            (tokens'', b) <- (f a).run tokens']

instance Alt (Parser token) where
    p <|> q = Parser $ \tokens ->
        case p.run tokens of
            [] -> q.run tokens
            result -> result

instance Plus (Parser token) where
    pzero = Parser (\tokens -> [])

satisfy :: (token -> Bool) -> Parser token token
satisfy predicate = Parser $ \tokens ->
    case tokens of
        [] -> []
        (t:rest) -> if predicate t
            then [(rest,t)]
            else []

many :: (Applicative f, Alt f) => f a -> f [a]
many !v = many_v
    where
        -- same definition as for some causes:
        -- ClassCastException: BlackHole cannot be cast to Lexer$TLexer
        many_v = (fmap (:) v <*> many_v) <|> pure []

some :: (Applicative f, Alt f) => f a -> f [a]
some !v = some_v
    where
        many_v = (fmap (:) v <*> many_v) <|> pure []
        some_v = (fmap (:) v) <*> many_v

item :: Parser token token
item = satisfy (const true)

symbol :: Eq token => token -> Parser token token
symbol t = satisfy (== t)

optional :: Parser token a -> Parser token (Maybe a)
optional parser = fmap Just parser <|> pure Nothing

