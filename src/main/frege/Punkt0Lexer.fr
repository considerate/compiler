module lexer.Punkt0Lexer where
import frege.Prelude hiding (LT)
import lexer.Lexer
import Data.HashMap

data Type = UnitType
    | BooleanType
    | IntType
    | StringType
derive Show Type
derive Eq Type

types :: [(String, Type)]
types = [("String", StringType), ("Unit", UnitType), ("Int", IntType), ("Boolean", BooleanType)]

data Literal = LitString String
    | LitInt Int
    | LitTrue
    | LitFalse
    | LitNull
    | LitThis
derive Show Literal
derive Eq Literal

atomicliterals :: [(String, Literal)]
atomicliterals = [("true", LitTrue), ("false", LitFalse), ("null", LitNull), ("this", LitThis)]

between before after mid = before *> mid <* after

-- match ", then match any char sequence (not '"'), then match " and return the char sequence
stringliteral = between (char '"') (char '"') $ fmap (LitString . packed) (many (satisfy (/= '"')))

intliteral = fmap (LitInt . atoi . packed) $ some digit

basicliteral = stringliteral <|> intliteral

data Operator = Plus
    | Minus
    | Times
    | Div
    | And
    | Or
    | Equals
    | Assign
    | LT
    | Noop
derive Show Operator
derive Eq Operator

comment = char '/' *> char '*' *> insidecomment
    where
        insidecomment = many (satisfy (/= '*')) *> char '*' *> (char '/' <|> insidecomment)

operator
    = (char '+' *> pure Plus)
    <|> (char '-' *> pure Minus)
    <|> (char '*' *> pure Times)
    <|> (string "&&" *> pure And)
    <|> (string "||" *> pure Or)
    <|> (char '=' *> (char '=' *> pure Equals <|> pure Assign))
    <|> (char '<' *> pure LT)
    <|> (char '/' *> pure Div)

data Keyword = Class
    | Extends
    | Def
    | Override
    | Object
    | New
    | If
    | Else
    | While
    | Var
    | Println
derive Show Keyword
derive Eq Keyword

keywords :: [(String, Keyword)]
keywords = [ ("class", Class)
    , ("extends", Extends)
    , ("def", Def)
    , ("override", Override)
    , ("object", Object)
    , ("new", New)
    , ("if", If)
    , ("else", Else)
    , ("while", While)
    , ("var", Var)
    , ("println", Println)]

data Token
    = Op Operator
    | Type Type
    | Keyword Keyword
    | Literal Literal
    | Identifier String
    | LParen
    | RParen
    | LBrace
    | RBrace
    | Comma
    | Colon
    | SemiColon
    | Dot
    | Bang
derive Show Token
derive Eq Token

mapsnd f = map (\(x, v) -> (x, f v))

atomictokens :: HashMap String Token
atomictokens = fromList (mapsnd Type types ++ mapsnd Keyword keywords ++ mapsnd Literal atomicliterals)

checkstringtype :: String -> Token
checkstringtype str = case lookup str atomictokens of
    Nothing -> Identifier str
    Just atomic -> atomic

identifier = fmap (checkstringtype . packed) $ fmap (:) (letter <|> char '_') <*> many (alphanumeric <|> char '_')

whitespace = some space

getIdentifierString :: Token -> Maybe String
getIdentifierString (Identifier s) = Just s
getIdentifierString _ = Nothing

isLiteral :: Token -> Bool
isLiteral (Literal _) = true
isLiteral _ = false

getLiteral :: Token -> Literal
getLiteral (Literal l) = l
getLiteral _ = error "bad"

token
    = ignore whitespace
    <|> ignore comment
    <|> (char '(' *> pure LParen)
    <|> (char ')' *> pure RParen)
    <|> (char '{' *> pure LBrace)
    <|> (char '}' *> pure RBrace)
    <|> (char ':' *> pure Colon)
    <|> (char ';' *> pure SemiColon)
    <|> (char ',' *> pure Comma)
    <|> (char '.' *> pure Dot)
    <|> (char '!' *> pure Bang)
    <|> (fmap Op operator)
    <|> (fmap Literal basicliteral)
    <|> identifier

