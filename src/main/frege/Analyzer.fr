module punkt0.Analyzer where
import Data.HashMap
import punkt0.Reporter
import Data.Traversable(traverse)
import Data.List(sort, partition, group, find)
import punkt0.Positioned
import punkt0.parser.Grammar
import Control.monad.State
import punkt0.Phase
import punkt0.Errors
import punkt0.ScalaShow
import punkt0.Named
import punkt0.Typed

type Name = String
-- | Simulate HashSet using a HashMap with values as unit ()
type HashSet a = HashMap a ()

add :: Eq a => a -> HashSet a -> HashSet a
add x = insert x ()

type ClassName = String
type VarName = String
type MethodName = String
type Extends a = HashMap a a
type Inheritance a = HashMap a [a]

data Environment
    = Env
    { supers :: HashMap ClassName (HashSet ClassName)
    , classes :: HashMap ClassName ClassDeclaration
    , thisClass :: Maybe TType
    , fields :: HashMap VarName VarDeclaration
    , methods :: HashMap MethodName MethodDeclaration
    , parameters :: HashMap VarName (Identifier, Type)
    , locals :: HashMap VarName VarDeclaration
    , symbol :: Int
    }
derive Eq Environment

data AnalyzeError
    = NoSuchClass ClassName Position
    | NoSuchMethod ClassName MethodName Position
    | NotDeclared Name Position
    | CyclicDependencies ClassName Position
    | OverloadedField ClassName VarName Position
    | Override ClassName VarName Position
    | DuplicateDeclaration [Identifier]
    | InvalidThis Position
    | TypeError TypeError
derive Show AnalyzeError
derive Eq AnalyzeError

type Analyze a = Accumulate [AnalyzeError] a

-- | Find missing classes
missing :: (Named a, Eq a, Positioned a) => a -> HashSet a -> Extends a -> Analyze ()
missing baseClass declared extends = traverse checkExists extends *> ok
    where
        ok = pure ()
        checkExists super
            | super == baseClass = ok
            | otherwise
                = maybe
                    (if super `member` declared
                        then ok
                        else report1 (NoSuchClass (nameOf super) (position super)))
                    (const ok)
                    (lookup super extends)

-- | Expand inheritance chain
inheritance :: Eq a => a -> Extends a -> Inheritance a
inheritance baseClass extends = result
    where
        result = mapValues supers extends
        supers super = maybe [super] (super :) (lookup super result)

-- | Verify non-existance of circular dependencies
cycleChecks :: (Named a, Eq a, Positioned a) => Inheritance a -> Analyze (Inheritance a)
cycleChecks map = traverse throwCyclic (keys withCycles) *> pure map
    where
        -- set of all classes that have circular dependencies
        throwCyclic c = report1 (CyclicDependencies (nameOf c) (position c))
        withCycles = foldWithKey findCycles empty map
        findCycles :: (Named a, Eq a) => HashSet a -> a -> [a] -> HashSet a
        findCycles cycles c supers
            = if c `member` cycles
                then cycles
                else cycles `union` cycleCheck empty supers
        -- check for cycle in list of classes
        cycleCheck :: Eq a => HashSet a -> [a] -> HashSet a
        cycleCheck _ [] = empty -- no cycle found, return empty set
        cycleCheck visited (c:cs)
            = if member c visited -- if the class has already been visited there's a cycle
                then visited -- return set of all visited classes so far (all of them must be cyclic)
                else cycleCheck (add c visited) cs

namePos :: (Named a, Positioned a) => a -> (String, Position)
namePos decl = (nameOf decl, position decl)

toSet :: Eq a => [a] -> HashSet a
toSet xs = fromList $ fmap (\x -> (x, ())) xs

toSupers :: Named a => Inheritance a -> HashMap String (HashSet String)
toSupers inh = fromList . fmap convertOne $ each inh
    where
        convertOne (base, supers) = (nameOf base, toSet . fmap nameOf $ supers)

checkDependencies :: Program -> Analyze Environment
checkDependencies (Program classes _ _)
    = missing baseClass declared extends
    *> fmap setSupers (cycleChecks (inheritance baseClass extends))
        where
            (withExtend, declaredClasses) = partition (\c -> isJust $ c.extends) classes
            declared = toSet $ fmap namePos declaredClasses
            noExtends = fmap (const []) declared
            baseClass = ("Any", initialPosition)
            pair c = (namePos c, parent c)
            parent c = namePos . unJust $ c.extends
            extends = (fromList . fmap pair $ withExtend)
            setSupers inh
                = Env
                    { supers=toSupers (inh `union` noExtends)
                    , classes=empty
                    , thisClass=empty
                    , fields=empty
                    , methods=empty
                    , parameters=empty
                    , locals=empty
                    , symbol = 0
                    }

namedMap :: (Named a) => [a] -> HashMap String a
namedMap xs = fromList $ fmap (\x -> (nameOf x, x)) xs

noDups :: (WithId a) => [a] -> Analyze ()
noDups xs = errors *> ok
    where
        ok = pure ()
        errors = traverse (\dup -> report1 (DuplicateDeclaration dup)) dups
        hasDups [] = False
        hasDups [x] = False
        hasDups (x:y:_) = True
        dups = filter hasDups grouped
        grouped = group (sort $ fmap idOf xs)

tagIds :: (WithId a) => (Int -> SymbolType) -> Environment -> [a] -> (Int, [a])
tagIds symbolType env xs = (i' + env.symbol, xs')
    where
        (i', xs') = foldr (\c (i,cs) -> (i+1, tagId (l-i-1) c : cs)) (0, []) xs
        l = length xs
        tagId i c = setId (Symbol (env.symbol+i) (symbolType i) (idOf c)) c

try :: Analyze a -> Analyze b -> (a -> Analyze b) -> Analyze b
try lhs fail ok = case lhs of
    ALeft errors -> ALeft errors *> fail
    ARight s -> ok s

symbolizeNested :: (Environment -> a -> Analyze (Int, a)) -> Environment -> [a] -> Analyze (Int, [a])
symbolizeNested nested env xs = symbolizeNested' (env.symbol) xs []
    where
        symbolizeNested' i [] acc = pure (i, reverse acc)
        symbolizeNested' i (c:cs) acc
            = try (nested env.{symbol=i} c)
                (symbolizeNested' i cs acc)
                (\(i', c') -> symbolizeNested' i' cs (c':acc))


instance Alt Maybe where
    Nothing <|> a = a
    a <|> _ = a

typ :: Expression -> TType
typ (Typed t _) = t
typ _ = error "Internal error: expecting typed expression"

methodType :: Environment -> Expression -> MethodName -> Analyze TType
methodType env (Typed (TClass c) expr) methodName
    = maybe (report1 $ NoSuchMethod c methodName (position expr)) pure methodType
    where
        decl = lookup c env.classes
        method = decl >>= \cd -> find (\m -> nameOf m.name == methodName) cd.methods
        methodType = fmap typeOf method
methodType env expr name = report1 $ TypeError $ NotAnObject (typ expr) (position expr)

data TypeError
    = UnificationError TType TType Position
    | InvalidAddOperands TType TType Position
    | InvalidEq Position
    | InvalidNumOperands TType TType Position
    | NotAnObject TType Position
    | CallOnNonMethod TType Position
derive Show TypeError
derive Eq TypeError

-- t1 <: t2
-- t1 is a subtype of t2
unify :: Environment -> Position -> TType -> TType -> Analyze TType
unify env pos TInt TInt = pure TInt
unify env pos TBool TBool = pure TBool
unify env pos TString TString = pure TString
unify env pos (TClass c) (TClass d)
    | c == d = pure (TClass c)
    | otherwise = if d `member` unJust (lookup c env.supers)
        then pure (TClass c)
        else report1 (TypeError $ UnificationError (TClass c) (TClass d) pos)
unify env pos (TClass c) TAnyRef = pure (TClass c)
unify env pos t1 t2 = report1 (TypeError $ UnificationError t1 t2 pos)

-- Get the type that is the most specific
-- common type between the two types
-- This is the same as a least upper bound on the
-- subtyping relation <:
leastCommonType env pos (TClass c) (TClass d)
    | c == d = pure (TClass c)
    | otherwise = case (d `member` unJust (lookup c env.supers), c `member` unJust (lookup d env.supers)) of
        (True, _) -> pure (TClass c)
        (_, True) -> pure (TClass d)
        (_, _) -> report1 $ TypeError $ UnificationError (TClass c) (TClass d) pos
leastCommonType env pos (TClass c) TAnyRef = pure (TClass c)
leastCommonType env pos TAnyRef (TClass c) = pure (TClass c)
-- Unless the types are classes this is the same as normal unification
leastCommonType env pos t1 t2
    = unify env pos t1 t2

-- Unify type when applying arguments to method call
applyUnify :: Environment -> Position -> TType -> [TType] -> Analyze TType
applyUnify env pos (TMethod (tparams, treturn)) targs
    = traverse (\(p,a) -> unify env pos p a) (zip tparams targs)
    *> pure treturn
applying env pos t _ = report1 $ TypeError $ CallOnNonMethod t pos

idType :: (WithId a, Typed a) => a -> (Identifier, TType)
idType x = (idOf x, typeOf x)

-- turn an identifier into the same symbol as the declaration
-- where the given identifier was declared, also extract the
-- type for the declaration
symbolizeId :: Environment -> Identifier -> Analyze (Identifier, TType)
symbolizeId env (ID var pos)
    = let
        id' = (fmap idType (lookup var env.locals))
            <|> (fmap idType (lookup var env.parameters))
            <|> (fmap idType (lookup var env.fields))
            <|> (fmap idType (lookup var env.methods))
            <|> (fmap idType (lookup var env.classes))
    in maybe (report1 $ NotDeclared var pos) pure id'

-- TODO: Complete for all cases of expression
symbolizeExpression :: Environment -> Expression -> Analyze Expression
symbolizeExpression env (l@(LitInt i pos)) = pure $ Typed TInt $ l
symbolizeExpression env (l@(LitString s pos)) = pure $Typed TString $ l
symbolizeExpression env (l@(LitTrue pos)) = pure $ Typed TBool $ l
symbolizeExpression env (l@(LitFalse pos)) = pure $ Typed TBool $ l
symbolizeExpression env (l@(LitNull pos)) = pure $ Typed TAnyRef $ l
symbolizeExpression env (l@(LitThis pos)) = maybe (report1 $ InvalidThis pos) (\t -> pure $ Typed t l) env.thisClass
symbolizeExpression env (Identifier id pos)
    = fmap (\(i,t) -> Typed t (Identifier i pos)) (symbolizeId env id)
symbolizeExpression env (New obj pos)
    = fmap (\(o,t) -> Typed t (New o pos)) (symbolizeId env obj)
--symbolizeExpression env (BinOp lhs op rhs pos)
--    = fmap (\l r -> Typed $ leastCommonType (typ l) (typ r) $ BinOp l op r pos) symbolizeExpression env lhs <*> symbolizeExpression env rhs
symbolizeExpression env (MethodCall e name args pos)
    = try (fmap (,) (symbolizeExpression env e) <*> traverse (symbolizeExpression env) args)
        (ALeft [])
        createCall
    where
        createCall (e',args') = case methodType env e' (nameOf name) of
            ALeft errors -> ALeft errors
            ARight t -> fmap (\t' -> Typed t' $ MethodCall e' name args' pos) (applyUnify env pos t (fmap typ args'))
symbolizeExpression env (Assign var expr pos)
    = try (fmap (,) (symbolizeId env var) <*> (symbolizeExpression env expr))
        (ALeft [])
        assign
    where
        assign ((var',t), expr') = fmap (\t' -> Typed t' $ Assign var' expr' pos) (unify env pos t (typ expr'))
 -- symbolizeExpression env (Not expr, pos) =
 -- symbolizeExpression env (Block exprs pos) =
 -- symbolizeExpression env (If pred body elseBody pos) =
 -- symbolizeExpression env (While predicate body pos) =
 -- symbolizeExpression env (Println expr, pos) =
 -- symbolizeExpression env (Typed t expr) =

symbolizeField :: Environment -> VarDeclaration -> Analyze VarDeclaration
symbolizeField env (v@Var{expr}) = fmap (v.{expr=}) (symbolizeExpression env expr)

symbolizeMethod :: Environment -> MethodDeclaration -> Analyze (Int, MethodDeclaration)
symbolizeMethod env (m@MethodDeclaration{args,vars,exprs})
    = noDups (fmap idOf args ++ fmap idOf vars)
    *> fmap createMethod (traverse (symbolizeExpression env') exprs)
    where
        (i, args') = tagIds (\l -> LocalSymbol (l+1)) env args
        a = length args
        (j, vars') = tagIds (\l -> LocalSymbol (a+l+1)) env.{symbol=i} vars
        params = fromList $ fmap (\(id, t) -> (nameOf id, (id, t))) args'
        locals = namedMap vars'
        env' = env.{locals=locals, parameters=params, symbol=j}
        createMethod exprs' = (j, m.{exprs=exprs', args=args', vars=vars'})

noOverloads err supervars vars
    = traverse (\field -> report1 $ err (nameOf field) (position field)) overloads
    *> pure ()
    where
        overloads = vars `intersection` supervars

isOverride (MethodDeclaration{override}) = override

symbolizeClass :: Environment -> ClassDeclaration -> Analyze (Int, ClassDeclaration)
symbolizeClass env (Class name extends vars methods pos)
    = noDups declared
    *> noOverloads (OverloadedField className) supervars declaredIds
    *> noOverloads (OverloadedField className) supermethods declaredIds
    *> traverse (inSuperMethods supermethods) overrides
    *> fmap createClass
        (traverse (symbolizeField env') vars')
        <*> (symbolizeNested symbolizeMethod env' methods')
        <*> pure pos
    where
        className = nameOf name
        declared = fmap idOf vars ++ fmap idOf methods
        declaredIds = namedMap  $ fmap idOf vars' ++ fmap idOf newmethods
        inSuperMethods supermethods method
            = maybe
                (report1 $ Override className (nameOf method) (position method))
                (const (pure ()))
                (lookup (nameOf method) supermethods)
        (overrides, newmethods) = partition isOverride methods
        supers = env.supers
        ext = unJust (lookup (nameOf name) supers)
        superclasses = fmap (\c -> unJust (lookup c env.classes)) (keys ext)
        supervars = unions $ fmap (\c -> namedMap c.vars) superclasses
        supermethods = unions $ fmap (\c -> namedMap c.methods) superclasses
        (i, vars') = tagIds (const FieldSymbol) env vars
        (j, methods') = tagIds (const MethodSymbol) (env.{symbol=i}) methods
        env' = env.{fields=namedMap vars',methods=namedMap methods', symbol = j, thisClass=Just (TClass $ nameOf name)}
        createClass vs (k,ms) p = (k, Class name extends vs ms p)

symbolizeMain :: Environment -> MainDeclaration -> Analyze MainDeclaration
symbolizeMain env (main@Main{vars, body, pos}) =
    fmap createMain (traverse (symbolizeExpression env') body)
    where
        (i, vars') = tagIds LocalSymbol env vars
        createMain body' = main.{body=body', vars=vars'}
        env' = env.{locals=namedMap vars',symbol=i}

tagMain i (main@Main{name})
    = main.{name=Symbol i ClassSymbol name}

-- | symbolize semantically verifies names
-- | in the program and rewrites the program
-- | to include information about naming for
-- | identifiers
symbolize :: Environment -> Program -> Analyze Program
symbolize env (Program classes main pos)
    = noDups classes
    *> try (symbolizeNested symbolizeClass env' classes')
        (symbolizeMain env' main' *> pure (Program classes' main' pos))
        (\(j, cs) -> fmap (Program cs) (symbolizeMain env'.{symbol=j} main') <*> pure pos)
    where
        (i, classes') = tagIds (const ClassSymbol) env classes
        main' = tagMain i main
        env' = env.{ classes=namedMap classes', symbol = i+1}

analyzer program = case checkDependencies program of
    ARight env -> symbolize env program
    ALeft errors -> ALeft errors

runAnalyzer = fmap analyzer . (parseCode program)

showAnalyzeError :: String -> AnalyzeError -> String
showAnalyzeError input (NoSuchClass c p)
    = showErrorAt (lines input) ("No such class: " ++ c) p
showAnalyzeError input (NoSuchMethod c m p)
    = showErrorAt (lines input) ("No such method: " ++ m ++ " in class "++ c) p
showAnalyzeError input (CyclicDependencies c p)
    = showErrorAt (lines input) ("The class " ++ c ++ " has cyclic dependencies") p
showAnalyzeError input (OverloadedField c v p)
    = showErrorAt (lines input) ("Illegal overload of member " ++ v ++ " in class " ++ c) p
showAnalyzeError input (Override c v p)
    = showErrorAt (lines input) ("Override of method "++ v ++ " missing in super classes for class " ++ c) p
showAnalyzeError input (DuplicateDeclaration ids)
    = unlines $ "Error: Duplicate declarations" : concatMap (\i -> ("At " ++ scalashow (position i)) : showCursorAt (lines input) (position i)) ids
showAnalyzeError input (NotDeclared var pos)
    = showErrorAt (lines input) ("Not declared: " ++ var) pos
showAnalyzeError input (TypeError (UnificationError t1 t2 pos))
    = showErrorAt (lines input) ("Cannot unify type " ++ show t1 ++ " with type " ++ show t2) pos
showAnalyzeError input (TypeError err)
    = show err

analysisPhase :: (String, Program) -> Phase (String, Program)
analysisPhase (input, program)
    = phase $ case analyzer program of
        ARight a -> pure $ ARight (input, a)
        ALeft errors -> pure $ ALeft (fmap (showAnalyzeError input) errors)

main :: [String] -> IO ()
main [] = getContents >>= print . runAnalyzer
main (file:_) = readFile file >>= print . runAnalyzer
