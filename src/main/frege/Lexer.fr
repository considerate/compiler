module lexer.Lexer where
import Data.Monoid
import Control.Second(second)
import Data.List(find)
import Data.Char(isAlpha,isAlphaNum,isUpper,isDigit,isLower,isSpace)

-- Nicer looking function composition operator :)
infixr 6 ∘
f ∘ g = \x -> f (g x)
{-
instance Functor Result where
    fmap _ Bad = Bad
    fmap f (Accept t) = Accept (f t)

instance Applicative Result where
    pure = Accept

    Fail <*> _ = Fail
    _ <*> Fail = Fail
    Accept f <*> Accept x = Accept (f x)

instance Alt Result where
    Fail <|> parser = parser
    parser <|> Fail = parser

instance Monoid Monoid m => Result m where
    mempty = Accept mempty

    Accept as `mappend` Accept bs = Accept $ as <> bs
    Accept _ `mappend` err = err
    err `mappend` _ = err
-}

data ParseState
    = ParseState
    { input :: String
    , pos :: !Position
    , errorPos :: !Position
    }

data LexResult a = Ok a ParseState | Bad ParseState

data Lexer a = Lexer { run :: ParseState -> LexResult a}

instance Functor Lexer where
    fmap f lexer = Lexer $ \state ->
        case lexer.run state of
            Bad state' -> Bad state'
            Ok token state' -> Ok (f token) state'

instance Applicative Lexer where
    pure x = Lexer (\state -> Ok x state)

    fs <*> xs = Lexer $ \state ->
        case fs.run state of
            Bad state' -> Bad state'
            Ok f state' ->
                case xs.run state' of
                    Bad state'' -> Bad state''
                    Ok x state'' -> Ok (f x) state''

instance Monad Lexer where
    pure x = Lexer (\state -> Ok x state)

    xs >>= f = Lexer $ \state ->
        case xs.run state of
            Bad state' -> Bad state'
            Ok x state' -> (f x).run state'

{-
instance Functor (TokenParser symbol) where
    fmap f parser = pure f <*> parser

instance Applicative (TokenParser symbol) where
    pure = return
    (<*>) = ap

instance Monad (TokenParser symbol) where
    return x = TokenParser $ (\_ -> Ok x)

    parser >>= f = TokenParser $ \state ->
        case parser.run state of
            Failing pos -> Failing pos
            Ok token -> (f token).run state

type Next symbol token a = ParseState symbol -> token -> Result a
data Lexer symbol token
    = Lexer { run :: forall a. Next symbol token a -> TokenParser symbol a}

instance Functor (Lexer symbol) where
    fmap f lexer = lexer >>= \token ->
        pure (f token)

instance Applicative (Lexer symbol) where
    pure x = Lexer (\next -> next x)

    fs <*> xs =
        fs >>= \f ->
        xs >>= \x ->
        return $ f x

instance Monad (Lexer symbol) where
    pure x = Lexer (\next -> next x)

    lexer >>= f = Lexer (\next -> lexer.run (\x -> (f x).run next))

instance Alt (Lexer symbol) where
    lexer <|> lexer' = Lexer (\next -> (lexer.run next <|> lexer'.run next))

instance Plus (Lexer symbol) where
    pzero = Lexer (\next -> TokenParser (\state -> Failing state.errorPos))
-}
many :: (Applicative f, Plus f) => f a -> f [a]
many !v = many_v
    where
        many_v = (fmap (:) v <*> many_v) <|> pure []

some :: (Applicative f, Plus f) => f a -> f [a]
some !v = some_v
    where
        many_v = (fmap (:) v <*> many_v) <|> pure []
        some_v = (fmap (:) v) <*> many_v

item :: Lexer c c
item = Lexer $ \next ->
    TokenParser $ \state ->
    case state.input of
        [] -> Failing state.errorPos
        (c:cs) -> (next c).run $ state.{
            input = cs
            , pos = stepPosition c state.pos
            , errorPos = state.errorPos
            }

satisfy :: (c -> Bool) -> Lexer c c
satisfy predicate = item >>= \c ->
    if predicate c
    then pure c
    else pzero

char :: Eq c => c -> Lexer c c
char c = satisfy (==c)

string :: String -> Lexer Char [Char]
string = string' . unpacked

string' :: Eq c => [c] -> Lexer c [c]
string' [] = pure []
string' (c:cs) = fmap (:) (char c) <*> string' cs

pair :: Lexer s a -> Lexer s b -> Lexer s (a,b)
pair a b = fmap (,) a <*> b

pairWith :: (a -> b -> c) -> Lexer s a -> Lexer s b -> Lexer s c
pairWith f a b = fmap f a <*> b

digit :: Lexer Char Char
digit = satisfy isDigit

upper :: Lexer Char Char
upper = satisfy isUpper

lower :: Lexer Char Char
lower = satisfy isLower

letter :: Lexer Char Char
letter = satisfy isAlpha

alphanumeric :: Lexer Char Char
alphanumeric = satisfy isAlphaNum

space :: Lexer Char Char
space = satisfy isSpace

type Position = (Int, Int)
initialPosition :: Position
initialPosition = (1,1)

-- data Lexeme a = Bad Position | Ok Position a | EOF Position
-- derive Show (Lexeme a)

stepPosition :: Char -> Position -> Position
stepPosition '\n' (line, _) = (line+1,1)
stepPosition _ (line, col) = (line, col+1)

--runLexer :: Lexer symbol token -> [symbol] -> [(token, [symbol])]
--runLexer lexer = runTokenParser $ lexer.run (\token -> Accept token Fail)

-- scan :: TokenParser symbol token -> [symbol] -> Position -> (TokenParser symbol token, [symbol], Position)
-- scan parser startInput startPos = consume parser startPos startInput (Fail, startInput, startPos)

{-
runTokenParser :: TokenParser symbol token -> [symbol] -> [(token, [symbol])]
runTokenParser (Symbol f) (c:cs) = runTokenParser (f c) cs
runTokenParser (Accept x parser) cs = (x, cs) : runTokenParser parser cs
runTokenParser Fail _ = []

scan :: (Show a) => Lexer a -> Position -> [Char] -> (State a, [Char], Position)
scan lexer startPos startInput = consume lexer startPos startInput (NonTerminal, startInput, startPos)
    where
        consume (Lexer state edges) pos input lastScan =
            let currentScan = nextScan state
            in case input of
                [] -> currentScan
                (c:cs) -> case getNextLexer edges c of
                    Nothing -> currentScan
                    Just next -> consume (next <*> pure c) (stepPosition c pos) cs currentScan
            where
                nextScan NonTerminal = lastScan
                nextScan _ = (state, input, pos)

checkPrefix :: [Char] -> Position -> [Lexeme a] -> [Lexeme a]
checkPrefix prefix pos lexemes = case prefix of
    [] -> lexemes
    _ -> Bad pos : lexemes



isOk lexeme = case lexeme of
    Ok _ _ -> true
    _ -> false

ofOk (Ok _ x) = x
ofOk (Bad _) = error "Did not get a valid token"
ofOk (EOF _) = error "Did not get a valid token"

toValidTokens :: [Lexeme a] -> [a]
toValidTokens = map ofOk . filter (isOk)
-}
