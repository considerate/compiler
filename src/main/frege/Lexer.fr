module lexer.Lexer where
import Data.Monoid
import Control.Second(second)
import Data.List(find)
import Data.Char(isAlpha,isAlphaNum,isUpper,isDigit,isLower,isSpace)

-- Nicer looking function composition operator :)
infixr 6 ∘
f ∘ g = \x -> f (g x)

data LexResult s r
    = Symbol (s -> LexResult s r)
    | Fail
    | Ignore (LexResult s r)
    | Accept r (LexResult s r)

instance Show (Show r) => (LexResult s r) where
    show (Symbol f) = "Symbol"
    show Fail = "Fail"
    show (Ignore _) = "Ignore"
    show (Accept r next) = "Accept(" ++ (show r) ++ "," ++ (show next) ++ ")"

instance Functor (LexResult s) where
    fmap _ Fail = Fail
    fmap f (Ignore next) = Ignore (fmap f next)
    fmap f (Accept x result) = Accept (f x) (fmap f result)
    fmap f (Symbol g) = Symbol (fmap f . g)

instance Alt (LexResult s) where
    Symbol f <|> Symbol g = Symbol (\x -> f x <|> g x)
    Fail <|> lexer = lexer
    lexer <|> Fail = lexer
    Accept x lexer <|> lexer' = Accept x (lexer <|> lexer')
    lexer <|> Accept x lexer' = Accept x (lexer <|> lexer')
    Ignore lexer <|> lexer' = Ignore (lexer <|> lexer')
    lexer <|> Ignore lexer' = Ignore (lexer <|> lexer')

data Lexer s r = Lexer { run :: forall a. (r -> LexResult s a) -> LexResult s a}

runLexer :: Lexer s r -> (r -> LexResult s a) -> LexResult s a
runLexer lexer = lexer.run

instance Functor (Lexer s) where
    fmap f lexer = lexer >>= (\r -> pure (f r))

instance Applicative (Lexer s) where
    pure = return
    (<*>) = ap

instance Alt (Lexer s) where
    a <|> b = Lexer (\next -> a.run next <|> b.run next)

instance Plus (Lexer s) where
    pzero = Lexer (\next -> Fail)

instance Monad (Lexer s) where
    return x = Lexer (\next -> next x)

    lexer >>= f = Lexer (\next -> lexer.run (\x -> (f x).run next))

many :: (Applicative f, Plus f) => f a -> f [a]
many !v = many_v
    where
        many_v = (fmap (:) v <*> many_v) <|> pure []

some :: (Applicative f, Plus f) => f a -> f [a]
some !v = some_v
    where
        many_v = (fmap (:) v <*> many_v) <|> pure []
        some_v = (fmap (:) v) <*> many_v

ignore :: Lexer c a -> Lexer c b
ignore lexer = Lexer (\next -> lexer.run (\x -> Ignore Fail))

item :: Lexer c c
item = Lexer Symbol

satisfy :: (c -> Bool) -> Lexer c c
satisfy predicate = item >>= \c ->
    if predicate c
    then pure c
    else pzero

char :: Eq c => c -> Lexer c c
char c = satisfy (==c)

string :: String -> Lexer Char [Char]
string = string' . unpacked

string' :: Eq c => [c] -> Lexer c [c]
string' [] = pure []
string' (c:cs) = fmap (:) (char c) <*> string' cs

pair :: Lexer s a -> Lexer s b -> Lexer s (a,b)
pair a b = fmap (,) a <*> b

pairWith :: (a -> b -> c) -> Lexer s a -> Lexer s b -> Lexer s c
pairWith f a b = fmap f a <*> b

digit :: Lexer Char Char
digit = satisfy isDigit

upper :: Lexer Char Char
upper = satisfy isUpper

lower :: Lexer Char Char
lower = satisfy isLower

letter :: Lexer Char Char
letter = satisfy isAlpha

alphanumeric :: Lexer Char Char
alphanumeric = satisfy isAlphaNum

space :: Lexer Char Char
space = satisfy isSpace

type Position = (Int, Int)
initialPosition :: Position
initialPosition = (1,1)

stepPosition :: Char -> Position -> Position
stepPosition '\n' (line, _) = (line+1,1)
stepPosition _ (line, col) = (line, col+1)

data ScanResult a = None | T a | I
derive Show (ScanResult a)

data Lexeme a = Bad Position | Ok Position a | EOF Position
derive Show (Lexeme a)

scan lexer startPos startInput
    | otherwise = consume lexer startPos startInput (None, startInput, startPos)
      where
        consume lexer pos input lastScan
         | otherwise =
            let currentScan = case lexer of
                    Accept x _ -> (T x, input, pos)
                    Ignore _ -> (I, input, pos)
                    _ -> lastScan
            in case input of
                [] -> currentScan
                (c:cs) -> case lexer of
                    Fail -> currentScan
                    Symbol f -> consume (f c) (stepPosition c pos) cs currentScan
                    Accept x next -> consume next (stepPosition c pos) input currentScan
                    Ignore next -> consume next (stepPosition c pos) input currentScan

scanToken'' Fail _ = []
scanToken'' (Symbol f) (c:cs) = scanToken'' (f c) cs
scanToken'' (Accept x next) cs = (x,cs) : scanToken'' next cs

scanOneToken :: Lexer c a -> [c] -> [(a, [c])]
scanOneToken lexer = scanToken'' (lexer.run (\x -> Accept x Fail))

scanToken' r pos cs = scan r pos cs

scanToken :: Show a => Lexer Char a -> Position -> [Char] -> (ScanResult a, [Char], Position)
scanToken lexer = scanToken' (runLexer lexer (\x -> Accept x Fail))

checkPrefix :: [Char] -> Position -> [Lexeme a] -> [Lexeme a]
checkPrefix prefix pos lexemes = case prefix of
    [] -> lexemes
    _ -> Bad pos : lexemes

scanTokens :: (Show a) => Lexer Char a -> [Char] -> [Lexeme a]
scanTokens lexer = tokenize (initialPosition, initialPosition) []
    where
        tokenize (pos, errPos) prefix input =
            let scanned = scanToken lexer pos input
            in case scanned of
                (None, [], pos') -> checkPrefix prefix errPos [EOF pos']
                (None, c:input', pos') -> tokenize (stepPosition c pos', errPos) (c:prefix) input'
                (T token, input', pos') ->  checkPrefix prefix errPos $ Ok pos token : tokenize (pos', pos') [] input'
                (I, input', pos') -> checkPrefix prefix errPos $ tokenize (pos', pos') [] input'

isOk lexeme = case lexeme of
    Ok _ _ -> true
    _ -> false

ofOk (Ok _ x) = x
ofOk (Bad _) = error "Did not get a valid token"
ofOk (EOF _) = error "Did not get a valid token"

toValidTokens :: [Lexeme a] -> [a]
toValidTokens = map ofOk . filter (isOk)
