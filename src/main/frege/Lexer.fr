module lexer.Lexer where
import Data.Monoid
import Control.Second(second)
import Data.List(find)
import Data.Char(isAlpha,isAlphaNum,isUpper,isDigit,isLower,isSpace)

-- Nicer looking function composition operator :)
infixr 6 ∘
f ∘ g = \x -> f (g x)

data ParseState
    = ParseState
    { input :: String
    , pos :: Position
    , errorPos :: Position
    }

data ParseResult s r
    = Symbol (s -> ParseResult s r)
    | Fail
    | Accept r (ParseResult s r)

instance Functor (ParseResult s) where
    fmap _ Fail = Fail
    fmap f (Accept x result) = Accept (f x) (fmap f result)
    fmap f (Symbol g) = Symbol (fmap f . g)

instance Alt (ParseResult s) where
    Symbol f <|> Symbol g = Symbol (\x -> f x <|> g x)
    Fail <|> lexer = lexer
    lexer <|> Fail = lexer
    Accept x lexer <|> lexer' = Accept x (lexer <|> lexer')
    lexer <|> Accept x lexer' = Accept x (lexer <|> lexer')

data Lexer s r = Lexer { run :: forall a. (r -> ParseResult s a) -> ParseResult s a}

runLexer :: Lexer s r -> (r -> ParseResult s a) -> ParseResult s a
runLexer lexer = lexer.run



instance Functor (Lexer s) where
    fmap f parser = parser >>= (\r -> pure (f r))

instance Applicative (Lexer s) where
    pure = return
    (<*>) = ap

instance Alt (Lexer s) where
    a <|> b = Lexer (\next -> runLexer a next <|> runLexer b next)

instance Plus (Lexer s) where
    pzero = Lexer (\next -> Fail)

instance Monad (Lexer s) where
    return x = Lexer (\next -> next x)

    lexer >>= f = Lexer (\next -> runLexer lexer (\x -> runLexer (f x) next))

many :: (Applicative f, Plus f) => f a -> f [a]
many !v = many_v
    where
        many_v = (fmap (:) v <*> many_v) <|> pure []

some :: (Applicative f, Plus f) => f a -> f [a]
some !v = some_v
    where
        many_v = (fmap (:) v <*> many_v) <|> pure []
        some_v = (fmap (:) v) <*> many_v

item :: Lexer c c
item = Lexer Symbol

satisfy :: (c -> Bool) -> Lexer c c
satisfy predicate = item >>= \c ->
    if predicate c
    then pure c
    else pzero

char :: Eq c => c -> Lexer c c
char c = satisfy (==c)

string :: String -> Lexer Char [Char]
string = string' . unpacked

string' :: Eq c => [c] -> Lexer c [c]
string' [] = pure []
string' (c:cs) = fmap (:) (char c) <*> string' cs

pair :: Lexer s a -> Lexer s b -> Lexer s (a,b)
pair a b = fmap (,) a <*> b

pairWith :: (a -> b -> c) -> Lexer s a -> Lexer s b -> Lexer s c
pairWith f a b = fmap f a <*> b

digit :: Lexer Char Char
digit = satisfy isDigit

upper :: Lexer Char Char
upper = satisfy isUpper

lower :: Lexer Char Char
lower = satisfy isLower

letter :: Lexer Char Char
letter = satisfy isAlpha

alphanumeric :: Lexer Char Char
alphanumeric = satisfy isAlphaNum

space :: Lexer Char Char
space = satisfy isSpace

type Position = (Int, Int)
initialPosition :: Position
initialPosition = (1,1)

stepPosition :: Char -> Position -> Position
stepPosition '\n' (line, _) = (line+1,1)
stepPosition _ (line, col) = (line, col+1)

data ScanResult a = None | T a
derive Show (ScanResult a)

data Lexeme a = Bad Position | Ok Position a | EOF Position
derive Show (Lexeme a)

scan lexer startPos startInput = consume lexer startPos startInput (None, startInput, startPos)
    where
        consume lexer pos input lastScan =
            case input of
                [] -> lastScan
                (c:cs) -> case lexer of
                    Fail -> lastScan
                    Symbol f -> consume (f c) (stepPosition c pos) cs lastScan
                    Accept x next -> consume next (stepPosition c pos) input (T x, input, pos)

scanToken' r pos cs = scan r pos cs

scanToken lexer = scanToken' (runLexer lexer (\x -> Accept x Fail))

checkPrefix :: [Char] -> Position -> [Lexeme a] -> [Lexeme a]
checkPrefix prefix pos lexemes = case prefix of
    [] -> lexemes
    _ -> Bad pos : lexemes

scanTokens :: (Show a) => Lexer Char a -> [Char] -> [Lexeme a]
scanTokens lexer = tokenize (initialPosition, initialPosition) []
    where
        tokenize (pos, errPos) prefix input =
            let scanned = scanToken lexer pos input
            in case scanned of
                (None, [], pos') -> checkPrefix prefix errPos [EOF pos']
                (None, c:input', pos') -> tokenize (stepPosition c pos', errPos) (c:prefix) input'
                (T token, input', pos') ->  checkPrefix prefix errPos $ Ok pos token : tokenize (pos', pos') [] input'

isOk lexeme = case lexeme of
    Ok _ _ -> true
    _ -> false

ofOk (Ok _ x) = x
ofOk (Bad _) = error "Did not get a valid token"
ofOk (EOF _) = error "Did not get a valid token"

toValidTokens :: [Lexeme a] -> [a]
toValidTokens = map ofOk . filter (isOk)
