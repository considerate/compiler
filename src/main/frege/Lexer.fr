module lexer.Lexer where
import Data.Monoid
import Control.Second(second)
import Data.List(find)
import Data.Char(isAlpha,isAlphaNum,isUpper,isDigit,isLower,isSpace)

data LexResult r
    = Fail (CharSequence,Position)
    | Ignore (CharSequence,Position)
    | Accept r (CharSequence,Position)

instance (Show r) => Show (LexResult r) where
    show (Fail _) = "Fail"
    show (Ignore _) = "Ignore"
    show (Accept r _) = "Accept(" ++ (show r) ++ ")"

instance Functor LexResult where
    fmap _ (Fail rest) = Fail rest
    fmap f (Ignore rest) = Ignore rest
    fmap f (Accept x rest) = Accept (f x) rest

type Win a r = CharSequence -> Position -> a -> LexResult r
type Lose r = CharSequence -> Position -> LexResult r
type Ignore r = CharSequence -> Position -> LexResult r

data Lexer a
    = Lexer {
    run :: forall r.
        CharSequence ->
        Position ->
        Lose r ->
        Ignore r ->
        Win a r ->
        LexResult r
    }

instance Functor Lexer where
    fmap !f lexer = Lexer (\ !buffer !pos !lose !ign !win ->
        let win' !buffer' !pos' !a = win buffer' pos' (f a)
        in lexer.run buffer pos lose ign win')

instance Monad Lexer where
    pure x = Lexer (\ !buffer !pos !lose !ign !win -> win buffer pos x)
    !lexer >>= !f
        = Lexer (\ !buffer !pos !lose !ign !win ->
            let win' !buffer' !pos' !a = let lexer' = f a in lexer'.run buffer' pos' lose ign win
            in lexer.run buffer pos lose ign win')

instance Alt Lexer where
    !a <|> !b
        = Lexer (\ !buffer !pos !lose !ign !win ->
        let lose' !buffer' !pos' = b.run buffer' pos' lose ign win
        in a.run buffer pos lose' ign win
        )

instance Plus Lexer where
    pzero = Lexer (\ !buffer !pos !lose !ign !win -> lose buffer pos)


many :: (Applicative f, Plus f) => f a -> f [a]
many !v = many_v
    where
        many_v = (fmap (:) v <*> many_v) <|> pure []

some :: (Applicative f, Plus f) => f a -> f [a]
some !v = some_v
    where
        many_v = (fmap (:) v <*> many_v) <|> pure []
        some_v = (fmap (:) v) <*> many_v

type Position = (Int, Int, Int)
initialPosition :: Position
initialPosition = (0,1,1)

posIndex (!index, _, _) = index

stepPosition :: Char -> Position -> Position
stepPosition '\n' (!index, !line, _) = (index+1, line+1, 1)
stepPosition _ (!index, !line, !col) = (index+1, line, col+1)

chatAtPos :: Position -> CharSequence -> Maybe Char
chatAtPos !pos !buffer
    = if (posIndex pos) < buffer.length
        then let c = buffer.charAt (posIndex pos)
            in Just c
        else Nothing

satisfy :: (Char -> Bool) -> Lexer Char
satisfy predicate
    = Lexer (\ !buffer !pos !lose !ign !win ->
            case chatAtPos pos buffer of {
                Nothing -> lose buffer pos;
                Just !c  ->
                    if predicate c
                        then win buffer (stepPosition c pos) c
                        else lose buffer pos
                })

ignore :: Lexer a -> Lexer b
ignore lexer
    = Lexer (\buffer !pos !lose !ign !win ->
        let win' !buffer' !pos' _ = ign buffer pos'
        in lexer.run buffer pos lose ign win')

failLexer !buffer !pos = Fail (buffer,pos)
ignoreLexer !buffer !pos = Ignore (buffer,pos)
winLexer !buffer !pos !a = Accept a (buffer,pos)

lex' :: Lexer a -> CharSequence -> Position -> LexResult a
lex' !lexer !buffer !pos = lexer.run buffer pos failLexer ignoreLexer winLexer

lex :: Lexer a -> CharSequence -> LexResult a
lex !lexer !buffer = lex' lexer buffer initialPosition

data Lexeme a = Bad Position | Ok Position a | EOF Position
derive Show (Lexeme a)

scanTokens :: (Show a) => Lexer a -> CharSequence -> [Lexeme a]
scanTokens !lexer !buffer = go (buffer, initialPosition)
    where
        go (!buffer, !pos) =
            let result = lex' lexer buffer pos
            in case result of
                Fail (buffer', pos') ->
                    if posIndex pos' >= buffer'.length - 1
                        then []
                        else Bad pos : go (buffer', stepPosition (buffer.charAt $ posIndex pos') pos')
                Ignore (buffer', pos') -> go (buffer', pos')
                Accept x (buffer', pos') -> Ok pos x : go (buffer', pos')

item :: Lexer Char
item = satisfy (const true)

char :: Char -> Lexer Char
char c = satisfy (==c)

string :: String -> Lexer [Char]
string = string' . unpacked

string' :: [Char] -> Lexer [Char]
string' [] = pure []
string' (c:cs) = fmap (:) (char c) <*> string' cs

pair :: Lexer a -> Lexer b -> Lexer (a,b)
pair a b = fmap (,) a <*> b

pairWith :: (a -> b -> c) -> Lexer a -> Lexer b -> Lexer c
pairWith f a b = fmap f a <*> b

digit :: Lexer Char
digit = satisfy isDigit

upper :: Lexer Char
upper = satisfy isUpper

lower :: Lexer Char
lower = satisfy isLower

letter :: Lexer Char
letter = satisfy isAlpha

alphanumeric :: Lexer Char
alphanumeric = satisfy isAlphaNum

space :: Lexer Char
space = satisfy isSpace

data ScanResult a = None | T a | I
derive Show (ScanResult a)

isOk lexeme = case lexeme of
    Ok _ _ -> true
    _ -> false

ofOk (Ok _ x) = x
ofOk (Bad _) = error "Did not get a valid token"
ofOk (EOF _) = error "Did not get a valid token"

toValidTokens :: [Lexeme a] -> [a]
toValidTokens = map ofOk . filter (isOk)
