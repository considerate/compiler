module lexer.Lexer where
import Data.Monoid
import Data.Iterators(StringIterator)
import Control.Second(second)
import Data.List(find)
import Data.Char(isAlpha,isAlphaNum,isUpper,isDigit,isLower,isSpace)

abstract data Lexer state token result
    = L { !run :: (state token) -> (Maybe (String | result), state token)}

instance Monad (Lexer state token) where
    pure x = Lexer.L (\pos -> (Just (Right x), pos))
    Lexer.L lexer >>= f = Lexer.L bind
        where
            bind pos = case lexer pos of
                (Just (Right result), pos') = case f result of
                    Lexer.L lexer' = lexer' pos'
                (Just (Left err), pos') = (Just (Left err), pos')
                (Nothing, pos') = (Nothing, pos')

instance Alt (Lexer state token) where
    Lexer.L lexer <|> Lexer.L lexer' = Lexer.L firstok
        where
            firstok pos = case lexer pos of
                (Just (Left err), pos') -> lexer' pos'
                right -> right

instance Plus (Lexer state token) where
    pzero = Lexer.L (\pos -> (Just (Left "Fail"), pos))

optional lexer = (fmap Just lexer) <|> return Nothing

-- strictly accumulate many tokens
many !p = fmap reverse (many' [])
    where
        many' acc = do
            a <- optional p
            case a  of
                Nothing -> return acc
                Just a  -> many' (a:acc)

some p = p >>= (\x -> fmap (x:) (many p))


ignore :: Lexer state token a -> Lexer state token b
ignore lexer = Lexer.L discard
    where
        discard pos = case lexer.run pos of
            (Just (Left err), pos') = (Just (Left err), pos')
            (_, pos') = (Nothing, pos')

eof = Lexer.L isOver
    where
        isOver pos = case uncons pos of
            Just (head, _) = (Just (Left "expected EOF"), pos)
            otherwise = (Just (Right ()), pos)

satisfy :: ListView state => (token -> Bool) -> Lexer state token token
satisfy !predicate = Lexer.L sat
    where
        sat pos = case uncons pos of
            Just (head, tail)
                | predicate head = (Just (Right head), tail)
            _ = (Just (Left "unexpected symbol"), pos)

item = satisfy (const true)

char c = satisfy (==c)

digit = satisfy (isDigit :: Char -> Bool)

upper = satisfy (isUpper :: Char -> Bool)

lower = satisfy (isLower :: Char -> Bool)

letter = satisfy (isAlpha :: Char -> Bool)

alphanumeric = satisfy (isAlphaNum :: Char -> Bool)

space = satisfy (isSpace :: Char -> Bool)

Lexer.L lexer <<|> Lexer.L lexer' = Lexer.L firstok
    where
        firstok pos = case lexer pos of
            (Just (Left err), pos') = lexer' pos'
            right = right

string = string' . unpacked

string' [] = pure []
string' (c:cs) = fmap (:) (char c) <*> string' cs


pairWith f a b = fmap f a <*> b
pair a b = pairWith (,)

data Lexeme a
    = Bad Int
    | Ok a Int
    | EOF Int
derive (Show (Lexeme a))

checkError :: (StringIterator Char, StringIterator Char) -> [Lexeme token] -> [Lexeme token]
checkError (!errPos, !pos) tokens
    = if errPos.at /= pos.at
      then Bad errPos.at : tokens
      else tokens

scanTokens :: Lexer StringIterator Char token -> StringIterator Char -> [Lexeme token]
scanTokens lexer startPos = go (startPos, startPos)
    where
        go (!errPos, !pos :: StringIterator Char) = case lexer.run pos of
            (Just (Right token), pos' :: StringIterator Char) = checkError (errPos, pos) $ Ok token (pos.at) : go (pos',pos')
            (Nothing, pos' :: StringIterator Char) = checkError (errPos, pos) $ go (pos',pos')
            (Just (Left _), pos' :: StringIterator Char) = case uncons pos' of
                Nothing = checkError (errPos, pos) $[EOF $ pos'.at]
                Just (_, rest) = if null rest
                    then checkError (errPos, pos) $[EOF $ pos'.at]
                    else go (errPos,rest)

