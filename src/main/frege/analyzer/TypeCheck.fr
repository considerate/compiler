module punkt0.analyzer.TypeCheck where
import Data.HashMap
import Data.Traversable(traverse)
import punkt0.Positioned
import punkt0.Typed
import punkt0.parser.Grammar
import punkt0.Reporter
import punkt0.analyzer.Types

type Supers = HashMap String (HashSet String)
type Environment = (Supers, HashMap String Identifier)
-- t1 <: t2
-- t1 is a subtype of t2
unify :: Environment -> Position -> TType -> TType -> Analyze TType
unify _ pos TInt TInt = pure TInt
unify _ pos TBool TBool = pure TBool
unify _ pos TString TString = pure TString
unify (supers, env) pos (TClass c) (TClass d)
    | c == d = pure (TClass c)
    | otherwise = if d `member` unJust (lookup c supers)
        then pure (TClass c)
        else report1 (TypeError $ UnificationError (TClass c) (TClass d) pos)
unify _ pos (TClass c) TAnyRef = pure (TClass c)
unify _ pos t1 t2 = report1 (TypeError $ UnificationError t1 t2 pos)

-- Get the type that is the most specific
-- common type between the two types
-- This is the same as a least upper bound on the
-- subtyping relation <:
leastCommonType (supers, env) pos (TClass c) (TClass d)
    | c == d = pure (TClass c)
    | otherwise = case (d `member` unJust (lookup c supers), c `member` unJust (lookup d supers)) of
        (True, _) -> pure (TClass c)
        (_, True) -> pure (TClass d)
        (_, _) -> report1 $ TypeError $ UnificationError (TClass c) (TClass d) pos
leastCommonType env pos (TClass c) TAnyRef = pure (TClass c)
leastCommonType env pos TAnyRef (TClass c) = pure (TClass c)
-- Unless the types are classes this is the same as normal unification
leastCommonType env pos t1 t2
    = unify env pos t1 t2

-- Unify type when applying arguments to method call
applyUnify :: Environment -> Position -> TType -> [TType] -> Analyze TType
applyUnify env pos (TMethod (tparams, treturn)) targs
    = traverse (\(p,a) -> unify env pos a p) (zip tparams targs)
    *> pure treturn
applyUnify env pos t _ = report1 $ TypeError $ CallOnNonMethod t pos

{-


idType :: (WithId a, Typed a) => a -> (Identifier, TType)
idType x = (idOf x, typeOf x)

typecheckMethod :: Environment -> MethodDeclaration -> Analyze MethodDeclaration
typecheckMethod env (MethodDeclaration override name args returnType vars exprs pos)
    = toAccumulate check
    where
        params = fromList (fmap (\(id, t) -> (nameOf id, (id, t))) args)
        env' = env.{locals=namedMap vars, parameters=params}
        check = toEither (typecheckExpression env' (Block exprs pos))
            >>= \(Typed t (Block exprs' _)) ->
                toEither (unify env pos t (ttype returnType) *> traverse (typecheckVar env') vars)
            >>= \vars' -> pure (MethodDeclaration override name args returnType vars' exprs' pos)

typecheckVar :: Environment -> VarDeclaration -> Analyze VarDeclaration
typecheckVar env (Var name varType expr pos)
    = toAccumulate check
    where
        check = toEither (typecheckExpression env expr)
            >>= \expr' -> toEither (exprType env expr')
            >>= \t -> toEither (unify env pos (ttype varType) t)
            >>= \_ -> pure (Var name varType expr' pos)

equalType :: Position -> MethodDeclaration -> MethodDeclaration -> Analyze ()
equalType pos a1 a2
    = if t1 /= t2
        then report1 $ TypeError $ UnificationError t1 t2 (position a1)
        else pure ()
    where
        t1 = typeOf a1
        t2 = typeOf a2

typecheckClass :: Environment -> ClassDeclaration -> Analyze ClassDeclaration
typecheckClass env (Class name extends vars methods pos)
    = sequenceA (intersectionWith (equalType pos) overrides supermethods)
    *> fmap (Class name extends)
        (traverse (typecheckVar env') vars)
        <*> (traverse (typecheckMethod env') methods)
        <*> pure pos
    where
        overrides = namedMap (filter isOverride methods)
        parentinterface = extends >>= \parent -> lookup (nameOf parent) env.interfaces
        (supervars, supermethods, names) = maybe (empty, empty, empty) id parentinterface
        (vars', methods', _) = unJust $ lookup (nameOf name) env.interfaces
        env' = env.{fields=vars', methods=methods'}

typecheckMain :: Environment -> MainDeclaration -> Analyze MainDeclaration
typecheckMain _ = pure

typecheck :: Environment -> Program -> Analyze Program
typecheck env _ | traceLn (showInterfaces env.interfaces) = undefined
typecheck env (Program classes main pos)
    = fmap Program
        (traverse (typecheckClass env') classes)
        <*> typecheckMain env main
        <*> pure pos
    where
        env' = env.{classes=namedMap classes}

exprType :: Environment -> Expression -> Analyze TType
exprType env (Typed t _) = pure t
exprType env (LitInt _ _) = pure TInt
exprType env (LitString _ _) = pure TString
exprType env (LitTrue _) = pure TBool
exprType env (LitFalse _) = pure TBool
exprType env (LitNull _) = pure TAnyRef
exprType env (Identifier identifier pos) = lookupType env identifier
exprType env (New identifier pos) = lookupType env identifier
exprType env expr = report1 (TypeError $ CannotDeduceType expr)

methodType :: Environment -> MethodName -> Expression -> Analyze TType
methodType env methodName (Typed (TClass c) expr)
    = maybe (report1 $ NoSuchMethod c methodName (position expr)) pure methodType
    where
        iface = lookup c env.interfaces
        method = iface >>= \(_, methods, _) -> lookup methodName methods
        methodType = fmap typeOf method
methodType env name expr = report1 $ TypeError $ NotAnObject (typ expr) (position expr)

typecheckExpression :: Environment -> Expression -> Analyze Expression
typecheckExpression env (identifier@(Identifier id pos))
    = fmap Typed (lookupType env id) <*> pure identifier
typecheckExpression env (new@(New obj pos))
    = fmap Typed (lookupType env obj) <*> pure new
typecheckExpression env (MethodCall expr name args pos)
    = toAccumulate check
    where
        check = toEither (typecheckExpression env expr)
            >>= \expr' -> toEither (methodType env (nameOf name) expr')
            >>= \t -> toEither (traverse (typecheckExpression env) args)
            >>= \args' -> toEither (traverse (exprType env) args')
            >>= \ts -> toEither (applyUnify env pos t ts)
            >>= \_ -> pure (MethodCall expr' name args' pos)
typecheckExpression env (Block exprs pos)
    = toAccumulate check
    where
        check =
            toEither (typecheckExpression env (last exprs))
            >>= \e -> toEither (exprType env e)
            >>= \t -> pure (Typed t (Block exprs pos))
typecheckExpression env expr
    | traceLn (showEnv env) = undefined
    | traceLn "missing cases for typecheck expr" = undefined
    | otherwise = toAccumulate check
        where
            check = toEither (exprType env expr)
                >>= \t -> pure (Typed t expr)

lookupType :: Environment -> Identifier -> Analyze TType
lookupType env id = let
    var = nameOf id
    t = (fmap typeOf (lookup var env.locals))
        <|> (fmap typeOf (lookup var env.parameters))
        <|> (fmap typeOf (lookup var env.fields))
        <|> (fmap typeOf (lookup var env.methods))
        <|> (fmap typeOf (lookup var env.classes))
    in maybe (report1 $ NotDeclared var (position id)) pure t

-}

